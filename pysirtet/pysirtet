#!/usr/bin/env python3

# Import python libs
import os
import re
import sys
import math
import copy
import enum
import random
import configparser
from decimal import Decimal as D
from datetime import datetime, timedelta
from argparse import ArgumentParser, ArgumentTypeError, ArgumentDefaultsHelpFormatter
import tkinter as tk


class Transformation(enum.Enum):
    identity = 0
    # Rotations
    cw = 1  # π/2 clockwise
    ccw = 2  # π/2 counterclockwise
    # Single row/column translations
    left = 3  # One column left
    right = 4  # One column right
    down = 5  # One row down
    # Extremal translations
    min = 6  # Left side
    max = 7  # Right side
    bottom = 8  # Bottom side


class GameState(enum.Enum):
    '''
    Account game state
    '''
    running = 0
    paused = 1
    over = 2


class EventType(enum.Enum):
    '''
    Types of asynchronous events used by the game
    '''
    iterate = 1
    remove = 2


class Polyomino:
    '''
    Define a polyomino by coordinates to the upper right corner of each of its
    squares and provide the valid transformations for a polyomino on the
    $\mathbb Z^2$ lattice
    '''
    def __init__(self, name, colors, coords):
        '''
        Setup attributes and coordinates
        '''
        self.name = name
        self.colors = colors

        # To minimize the distance between the polyomino proper origin and the
        # polyomino center of mass, coordinates can take integral and
        # half-integral values
        if any([v[0]%1 or v[1]%1 for v in coords]):
            self.coords = [[int(v[0] + D('-0.5')), int(v[1] + D('-0.5'))] for v in coords]
            self.o = [D('-0.5'), D('-0.5')]
        else:
            self.coords = coords
            self.o = [0, 0]
        self.ordinal = len(coords)  # Polyomino ordinal (4 == tetromino, etc.)

    def _check_grid(self, coords, grid):
        '''
        Validate whether the coordinates, which correspond to the upper right
        corner of a polyomino square are all available in the grid
        '''
        for v in coords:
            # Check that v points to the interior of the grid
            try:
                grid[v]
            except IndexError:
                return False
            # Check that v points to an unoccupied square
            if grid[v]['type'] != None:
                return False
        return True

    def min(self, dimension):
        '''
        Return the minimum coordinate of the polyomino in the given dimension
        ('x' corresponds to 0 and 'y' to 1)
        '''
        return min([c[dimension] for c in self.coords])

    def max(self, dimension):
        '''
        Return the maximum coordinate of the polyomino in the given dimension
        ('x' corresponds to 0 and 'y' to 1)
        '''
        return max([c[dimension] for c in self.coords])

    def rotate(self, direction, grid, **kwargs):
        '''
        Rotate polyomino clockwise or counterclockwise (±π/2) about its proper
        origin if the resulting transformation is contained within the grid and
        places the polyomino on unoccupied squares
        '''
        # Prepare new coordinates and rotation tensor
        coords = [[0, 0] for i in range(self.ordinal)]
        sgn = {
            Transformation.cw: -1,
            Transformation.ccw: 1,
        }.get(direction)

        # Apply rotation tensor if possible
        for i in range(self.ordinal):
            coords[i][0] = int(-sgn*(self.coords[i][1] - self.o[1]) + self.o[0])
            coords[i][1] = int(sgn*(self.coords[i][0] - self.o[0]) + self.o[1])
        if self._check_grid(coords, grid):
            self.coords = coords
            return True
        return False

    def translate(self, v, grid, incremental=False):
        '''
        Translate polyomino by the vector v if the resulting transformation
        places the polyomino within the grid and on unoccupied squares

        :param incremental: If true, move the polyomino one row/column at a
        time in the direction of v until the full translation, v, is achieved,
        or as far as possible along the direction of v
        '''
        # Redefine v as explicit coordinates in the grid reference frame
        if isinstance(v, Transformation):
            v = {
                Transformation.left: [-1, 0],
                Transformation.right: [1, 0],
                Transformation.down: [0, -1],
                Transformation.min: [-self.min(0), 0],
                Transformation.max: [grid.width - self.max(0) - 1, 0],
                Transformation.bottom: [0, -self.min(1)],
            }.get(v)
        # define unit form of v
        magnitude = D(math.sqrt(v[0]**2 + v[1]**2)) or 1  # Prevent zero division
        unit = [math.ceil(v[0]/magnitude), math.ceil(v[1]/magnitude)]

        # Prepare new coordinates and new proper origin in the grid frame
        coords = [[0, 0] for i in range(self.ordinal)]
        o = [0, 0]

        # Incrementally apply upto translation vector v
        success = None
        u = unit if incremental else v
        if u == [0, 0]:
            return success
        while True:
            for i in range(self.ordinal):
                coords[i][0] = self.coords[i][0] + u[0]
                coords[i][1] = self.coords[i][1] + u[1]
                o = [self.o[0] + u[0], self.o[1] + u[1]]
            if self._check_grid(coords, grid):
                self.coords = [[coord[0], coord[1]] for coord in coords]
                self.o = [o[0], o[1]]
                success = True
                if not incremental:
                    return success
            else:
                return success


tetrominoes = (
    Polyomino(
        name='Z',
        coords=[[D('-1.5'), 0], [D('-0.5'), 0], [D('-0.5'), -1], [D('0.5'), -1]],
        colors={'normal': '#CC6666',
                'light' : '#F89FAB',
                'dark'  : '#803C3B'},
    ),
    Polyomino(
        name='S',
        coords=[[D('-0.5'), -1], [D('0.5'), -1], [D('0.5'), 0], [D('1.5'), 0]],
        colors={'normal': '#66CC66',
                'light' : '#79FC79',
                'dark'  : '#3B803B'},
    ),
    Polyomino(
        name='l',
        coords=[[D('-1.5'), 0], [D('-0.5'), 0], [D('0.5'), 0], [D('1.5'), 0]],
        colors={'normal': '#6666CC',
                'light' : '#7979FC',
                'dark'  : '#3B3B80'},
    ),
    Polyomino(
        name='T',
        coords=[[-1, 0], [0, 0], [0, -1], [1, 0]],
        colors={'normal': '#CCCC66',
                'light' : '#FCFC79',
                'dark'  : '#80803B'},
    ),
    Polyomino(
        name='o',
        coords=[[D('-0.5'), D('0.5')], [D('-0.5'), D('-0.5')], [D('0.5'), D('0.5')], [D('0.5'), D('-0.5')]],
        colors={'normal': '#CC66CC',
                'light' : '#FC79FC',
                'dark'  : '#803B80'},
    ),
    Polyomino(
        name='L',
        coords=[[-1, 1], [-1, 0], [-1, -1], [0, -1]],
        colors={'normal': '#66CCCC',
                'light' : '#79FCFC',
                'dark'  : '#3B8080'},
    ),
    Polyomino(
        name='J',
        coords=[[0, 1], [0, 0], [0, -1], [-1, -1]],
        colors={'normal': '#DAAA00',
                'light' : '#FCC600',
                'dark'  : '#806200'},
    ),
)


class TimerVar(tk.StringVar):
    '''
    Timer string widget variable with start/stop facilities
    '''
    def __init__(self, *args, **kwargs):
        '''
        Setup TimeVar object
        '''
        self.counter = self._validate(kwargs.pop('value') if 'value' in kwargs else timedelta())
        self.counting_since = None  # Timestamp of last start/resume

        super().__init__(*args, value=self._to_str(self.counter), **kwargs)

    def _validate(self, value):
        '''
        Validate input value
        '''
        if isinstance(value, timedelta):
            return value
        else:
            raise TypeError('value must be of type timedelta')

    def _to_str(self, value):
        '''
        Convert value timedelta to string
        '''
        return str(value)[:7]

    def get(self):
        '''
        Get elapsed time as a string
        '''
        self.set()  # First update value to latest time
        return super().get()

    def set(self, value=None):
        '''
        Reset the timer with a new value or update the value to the current
        time
        '''
        if value != None:
            self.counter = self._validate(value)
            count = self.counter
            if not value:
                self.counting_since = datetime.now()
        elif self.counting_since:
            count = datetime.now() - self.counting_since + self.counter
        else:
            count = self.counter
        return super().set(self._to_str(count))

    def start(self):
        '''
        Begin/resume counting
        '''
        if not self.counting_since:
            self.counting_since = datetime.now()
        self.set()

    def stop(self):
        '''
        Accumulate active counting into counter and pause counting
        '''
        if self.counting_since:
            self.counter += datetime.now() - self.counting_since
            self.counting_since = None
        self.set()


class Grid:
    '''
    The rectangular region of squares that comprises the game state.  The
    squares map to the integer coordinates in the first quadrant of the
    cartesian plane such that each square is represented by the (integral)
    point at its upper right corner.  The origin corresponds to the upper right
    corner of the lower left square of the grid
    '''
    def __init__(self, opts, width, height):
        '''
        Setup game grid
        '''
        # Store program options
        self.opts = opts

        # Initialize internal grid
        self._grid = [[{'type': None, 'id': None, 'colors': {}, 'is_active': None} for i in range(height)] for j in range(width)]
        self.width = len(self._grid)
        self.height = len(self._grid[0])

    def __check_nonnegative(self, v):
        '''
        Disallow accessing squares by negative coordinates.  Python allows
        accessing elements of iterables by one modulus below the residual
        representation of the array, but we disallow it for simplicity
        '''
        if 0 > min(v):
            raise IndexError('grid coordinates must be nonnegative')

    def __getitem__(self, v):
        '''
        Retrieve the square details at coordinates v from the origin
        '''
        self.__check_nonnegative(v)
        return self._grid[v[0]][v[1]]

    def __setitem__(self, v, d):
        '''
        Update the square at coordinates v from the origin to be of tetromino
        type t with Tkinter item id i, where d is a dictionary of the form
        {'type': t, 'id': i)
        '''
        self.__check_nonnegative(v)
        self._grid[v[0]][v[1]].update(d)

    def __iter__(self):
        '''
        Iterate over the grid squares, providing both the coordinates and the
        square info
        '''
        for x in range(self.width):
            for y in range(self.height):
                yield (x, y), self[x, y]

    def print(self):
        '''
        Display grid state
        '''
        # Convert columns to rows
        rows = {}
        for v, square in self:
            if not v[1] in rows:
                rows[v[1]] = {}
            rows[v[1]][v[0]] = ' ' if square['type'] is None else square['type']
        for i, row in enumerate(rows):
            rows[i] = ''.join([2*rows[i][j] if len(rows[i][j]) == 1 else rows[i][j][:2] for j in sorted(rows[i].keys())])

        # Print rows with formatting
        digits = len(str(self.opts['board']['height']))
        row_fmt = '{{:0{}}}'.format(digits)
        print(digits*' ' + '+' + 2*len(self._grid)*'-' + '+')
        for i in reversed(list(rows.keys())):
            print(row_fmt.format(self.opts['board']['height'] - i - 1) + '|' + rows[i] + '|')
        print(digits*' ' + '+' + 2*len(self._grid)*'-' + '+')


class Board(tk.Canvas):
    '''
    Used to display polyomino block grid
    '''
    @property
    def width(self): return self.grid.width

    @property
    def height(self): return self.grid.height

    def __init__(self, opts, parent, width, height, is_projection=False):
        '''
        Setup board
        '''
        # Setup options
        self.opts = opts
        self.is_projection = is_projection
        self.border_width = self.opts['scale']//16
        self.aspect_proportion = 3 if self.is_projection else 1
        self.full_row_colors={'normal': '#DDDDDD',
                              'light' : '#FFFFFF',
                              'dark'  : '#BBBBBB'}
        self.pause_cover_id = None

        # Setup internal grid
        self.grid = Grid(self.opts, width, height)

        # Setup TK
        super().__init__(parent,
                         width=self.opts['scale']*width,
                         height=self.opts['scale']*height//self.aspect_proportion)
        self.create_rectangle(0, 0,
                              self.opts['scale']*width, self.opts['scale']*height,
                              fill='black',
                              outline='black',
                              width=self.border_width)

        if self.opts['debug']:
            for v, square in self.grid:
                u = self._transform_coord(v)
                self.create_text((self.opts['scale']*u[0], self.opts['scale']*u[1]),
                                 text='{},{}'.format(*u),
                                 fill='white', font=('Monospace', 5), anchor=tk.NW)

    def _transform_coord(self, v):
        '''
        pysirtet treats the game board as the first quadrant of the Cartesian
        plane with the origin at the lower left corner, whereas Tkinter,
        conventionally, places the origin in the upper left corner, with
        positive x and y directions pointing right and down, respectively.

        This function transforms pysirtet coordinates into Tkinter coordinates.
        '''
        return [v[0], self.height - 1 - v[1]]

    def _draw_square(self, v, colors):
        '''
        Draw or clear a polyomino square on the board at v
        '''
        u = self._transform_coord(v)
        u = [self.opts['scale']*u[0], self.opts['scale']*u[1]]
        return self.create_rectangle(u[0] + self.border_width, u[1] + self.border_width,
                                     u[0] + self.opts['scale'], u[1] + self.opts['scale']//self.aspect_proportion,
                                     fill=colors['normal'],
                                     outline=colors['dark'],
                                     width=self.border_width)

    def update(self, piece, clear=False, is_active=False):
        '''
        Place or clear piece on the board
        '''
        for v in piece.coords:
            u = [v[0], 0] if self.is_projection else v
            square = self.grid[u]
            if clear:
                square.update({'type': None,
                               'id': self.delete(square['id']),
                               'colors': {},
                               'is_active': None})
            else:
                if not square['id']:
                    colors = piece.colors[v[0]] if piece.name == 'row' and not piece.full else piece.colors
                    square.update({'type': piece.name,
                                   'id': self._draw_square(u, colors),
                                   'colors': colors,
                                   'is_active': is_active})

    def select_full_rows(self):
        '''
        Mark full rows with full row colors prior to removing them

        .. note::

            There is a low probability race condition that between the time of
            marking and the time of removal, new rows could become filled by
            the introduction of a new piece, such that they are removed and not
            marked as the board does not persist calculated data, such as which
            rows are full, by design: this incidental data is stateless and
            must be recalculated whenever it is needed.  The severity of the
            race condition is asymptotically constant as the rates of each
            independent game thread: marking and removing, adding new pieces,
            scale proportionally.
        '''
        has_full_rows = False
        for y in range(self.height):
            row_coords = [[x, y] for x in range(self.width) if self.grid[x, y]['type'] and not self.grid[x, y]['is_active']]
            if len(row_coords) == self.width:
                has_full_rows = True
                row = Polyomino('row', {v[0]: self.grid[v]['colors'] for v in row_coords}, row_coords)
                row.full = True
                row.colors = self.full_row_colors
                self.update(row, clear=True)
                self.update(row)
        return has_full_rows

    def _get_rows(self):
        '''
        Gather all full and partial rows
        '''
        rows = []
        full_count = 0
        for y in range(self.height):
            row_coords = [[x, y] for x in range(self.width) if self.grid[x, y]['type'] and not self.grid[x, y]['is_active']]
            if len(row_coords):
                row = Polyomino('row', {v[0]: self.grid[v]['colors'] for v in row_coords}, row_coords)
                rows.append(row)
                row.full = False
                row.full_below_count = full_count
            if len(row_coords) == self.width:
                full_count += 1
                row.full = True
                row.colors = self.full_row_colors
                self.update(row, clear=True)
                self.update(row)
        return full_count, rows

    def remove_full_rows(self):
        '''
        Remove full rows and move partial rows down into the vacancies; return
        number of removed rows
        '''
        full_count, rows = self._get_rows()
        for row in rows:
            if row.full:
                self.update(row, clear=True)
            elif row.full_below_count:
                self.update(row, clear=True)
                row.translate([0, -row.full_below_count], self.grid)
                self.update(row)
        return full_count

    def clear(self):
        '''
        Remove all occupied squares from the board
        '''
        full_count, rows = self._get_rows()
        for row in rows:
            self.update(row, clear=True)

    def add_pause_cover(self):
        '''
        Cover the board when game is paused
        '''
        if not self.pause_cover_id:
            self.pause_cover_id = self.create_rectangle(0, 0,
                                                        self.opts['scale']*(self.width + 1),
                                                        self.opts['scale']*(self.height + 1),
                                                        fill='black',
                                                        outline='black',
                                                        width=0)

    def remove_pause_cover(self):
        '''
        Uncover the board when game is paused
        '''
        if self.pause_cover_id:
            self.delete(self.pause_cover_id)
            self.pause_cover_id = None


class PySirtet(tk.Frame):
    '''
    Main game window
    '''
    def __init__(self, opts, master=None):
        '''
        Setup game
        '''
        # Setup options
        self.pdeg = 4  # Polyomino degree (hardcode to tetromino)
        self.opts = opts

        # Setup game data and state
        self.removed = {l + 1: tk.IntVar() for l in range(self.pdeg)}
        self.removed['total'] = tk.IntVar()

        self.piece_count = tk.IntVar()
        self.next_piece = None
        self.piece = None

        self.time_elapsed = TimerVar()
        self.time_elapsed.start()

        self.rate = tk.DoubleVar()
        self._set_rate()
        self.state_name = tk.StringVar()
        self.set_state(GameState.running)

        # Setup TK
        super().__init__(master)
        self.master = master
        self.pack()
        self.create_widgets()
        self.setup_events()
        self.add_piece()
        self.iterate_id = self._schedule(EventType.iterate)  # Start the game cycle

    def _schedule(self, event_type):
        '''
        Schedule an asynchronous event
        '''
        if event_type == EventType.iterate:
            action = self.iterate
            rate = self.rate.get()
        elif event_type == EventType.remove:
            action = self.remove_full_rows
            rate = self.rate.get()*self.opts['remove_freq']

        return self.master.after(int(1e3/rate), action)  # Convert seconds to milliseconds

    def _update_removed(self, rows_removed):
        '''
        Update the count of rows removed
        '''
        self.removed[rows_removed].set(self.removed[rows_removed].get() + 1)
        self.removed['total'].set(self.removed['total'].get() + rows_removed)

    def _set_rate(self):
        '''
        Update the game rate; ensure rate is >= 1
        '''
        new_rate = self.opts['initial_rate']*(1 if self.opts['constant'] else math.log(self.removed['total'].get()/2**4 + 2, 2))
        self.rate.set(round(max(new_rate, 1), 2))

    def _update_piece_on_board(self, clear=False, is_active=True):
        '''
        Place or clear piece and its projection or shadow on the board
        '''
        self.board.update(self.piece, clear=clear, is_active=is_active)
        if self.opts['shadow'] == 'projection':
            self.projection_board.update(self.piece, clear=clear, is_active=is_active)

    def create_widgets(self):
        '''
        Pack in game widgets
        '''
        # Game frame
        self.game = tk.Frame(self)
        self.game.pack(side='left')

        self.board = Board(self.opts, self.game, self.opts['board']['width'], self.opts['board']['height'])
        self.board.pack(side='top')

        if self.opts['shadow'] == 'projection':
            self.projection_board = Board(self.opts, self.game, self.opts['board']['width'], 1, is_projection=True)
            self.projection_board.pack(side='top')

        # Marquee frame
        self.marquee = tk.Frame(self)
        self.marquee.pack(side='right', padx=self.opts['scale'], pady=self.opts['scale'])

        self.preview_frame = tk.LabelFrame(self.marquee, text='preview')
        self.preview_frame.pack(side='top')
        self.preview_board = Board(self.opts, self.preview_frame, self.pdeg, self.pdeg)
        self.preview_board.pack(side='top')

        self.rate_frame = tk.LabelFrame(self.marquee, text='rate')
        self.rate_frame.pack(side='top')
        self.rate_display = tk.Label(self.rate_frame, textvariable=self.rate)
        self.rate_display.pack(side='left')
        self.rate_unit = tk.Label(self.rate_frame, text='blocks/sec')
        self.rate_unit.pack(side='left')

        self.used_frame = tk.LabelFrame(self.marquee, text='pieces used')
        self.used_frame.pack(side='top')
        self.used_display = tk.Label(self.used_frame, textvariable=self.piece_count, width=12)
        self.used_display.pack(side='top')

        self.removed_frame = tk.LabelFrame(self.marquee, text='rows removed')
        self.removed_frame.pack(side='top')
        self.removed_stack = {}
        for l in list(range(1, self.pdeg + 1)) + ['total']:
            stack = self.removed_stack[l] = {}
            stack['frame'] = tk.Frame(self.removed_frame, width=12)
            stack['frame'].pack(side='top')
            stack['display'] = tk.Label(stack['frame'], textvariable=self.removed[l])
            stack['display'].pack(side='left')
            stack['unit'] = tk.Label(stack['frame'], text='{}{}'.format('' if l == 'total' else 'x', l))
            stack['unit'].pack(side='left')

        self.time_elapsed_frame = tk.LabelFrame(self.marquee, text='elapsed time')
        self.time_elapsed_frame.pack(side='top')
        self.time_elapsed_display = tk.Label(self.time_elapsed_frame, textvariable=self.time_elapsed, width=12)
        self.time_elapsed_display.pack(side='top')

        self.state_display = tk.Label(self.marquee, textvariable=self.state_name)
        self.state_display.pack(side='top')

    def set_state(self, state):
        '''
        Set the game state
        '''
        self.state = state
        self.state_name.set({
            GameState.running: '',
            GameState.paused: 'paused',
            GameState.over: 'game over',
        }.get(state))

    def setup_events(self):
        '''
        Respond to inputs and other game conditions: mainly key input
        '''
        for name, key in self.opts['keys'].items():
            self.master.bind(key, getattr(self, name))

    def pause(self, event):
        '''
        (Un)pause the game
        '''
        if self.state == GameState.running:
            self.after_cancel(self.iterate_id)
            self.time_elapsed.stop()
            for board in (self.board, self.preview_board, self.projection_board):
                board.add_pause_cover()
            self.set_state(GameState.paused)
        elif self.state == GameState.paused:
            self.iterate_id = self._schedule(EventType.iterate)
            self.time_elapsed.start()
            for board in (self.board, self.preview_board, self.projection_board):
                board.remove_pause_cover()
            self.set_state(GameState.running)

    def move(transformation):
        '''
        Map keys to transformations on the current piece
        '''
        def transform(self, event):
            '''
            Transform the current piece
            '''
            if self.state == GameState.running:
                self.move_piece(transformation)
        return transform

    left = move(Transformation.left)
    right = move(Transformation.right)
    left_side = move(Transformation.min)
    right_side = move(Transformation.max)
    rotate_left = move(Transformation.ccw)
    rotate_right = move(Transformation.cw)
    down = move(Transformation.down)
    drop = move(Transformation.bottom)

    def restart(self):
        '''
        Restart the game
        '''
        # Setup game state
        self.board.clear()
        self.projection_board.clear()
        self.piece = None

        for removed_counter in self.removed.values():
            removed_counter.set(0)
        self.piece_count.set(0)

        self.time_elapsed.set(timedelta())
        self.time_elapsed.start()

        self._set_rate()
        self.set_state(GameState.running)

        # Setup TK
        self.restart_button.destroy()
        self.add_piece()
        self.iterate_id = self._schedule(EventType.iterate)

    def iterate(self):
        '''
        Move the active piece one row down
        '''
        if self.state == GameState.paused:
            return
        if not self.move_piece(Transformation.down):
            self._update_piece_on_board(clear=True)  # Remove active
            self._update_piece_on_board(is_active=False)  # Now inactive
            if self.board.select_full_rows():
                self._schedule(EventType.remove)
            self.add_piece()
        if self.opts['debug']:
            self.board.grid.print()
        if self.state == GameState.running:
            self.time_elapsed.set()
            self.iterate_id = self._schedule(EventType.iterate)
        elif self.state == GameState.over:
            self.restart_button = tk.Button(self.marquee, text='restart', command=self.restart)
            self.restart_button.pack(side='top')

    def add_piece(self):
        '''
        Add a tetromino to the top center of the board
        '''
        def get_next_piece():
            '''
            Get a new piece
            '''
            self.preview_board.clear()
            name = random.choice(tetrominoes).name
            self.next_piece = copy.deepcopy([t for t in tetrominoes if t.name == name][0])
            self.next_piece.translate([self.preview_board.width//2,
                                       self.preview_board.height//2],
                                      self.preview_board.grid)
            self.preview_board.update(self.next_piece)

        if not self.next_piece:
            get_next_piece()
        self.piece = copy.deepcopy(self.next_piece)
        self.piece_count.set(self.piece_count.get() + 1)
        get_next_piece()

        if self.piece.translate([self.board.width//2 - self.preview_board.width//2,
                                 self.board.height - 1 - self.piece.max(1)],
                                self.board.grid):
            if self.opts['shadow'] == 'projection':
                self.projection_board.clear()
            self._update_piece_on_board()
        else:
            self.set_state(GameState.over)

    def move_piece(self, movement):
        '''
        Move current piece according to the movement requested:

        - (cw) Rotate π/2 clockwise about piece proper origin
        - (ccw) Rotate π/2 counterclockwise about piece proper origin
        - (left) One column left
        - (right) One column right
        - (down) One row down
        - (min) To the leftmost available position
        - (max) To the rightmost available position
        - (bottom) To the lowest available position
        '''
        # Map each movement to a predefined transformation on the current piece
        transform, kwargs = {
            Transformation.cw: (self.piece.rotate, {}),
            Transformation.ccw: (self.piece.rotate, {}),
            Transformation.left: (self.piece.translate, {}),
            Transformation.right: (self.piece.translate, {}),
            Transformation.down: (self.piece.translate, {}),
            Transformation.min: (self.piece.translate, {'incremental': True}),
            Transformation.max: (self.piece.translate, {'incremental': True}),
            Transformation.bottom: (self.piece.translate, {'incremental': True}),
        }.get(movement)
        # Execute the transformation on the current piece if possible
        self._update_piece_on_board(clear=True)
        result = transform(movement, self.board.grid, **kwargs)
        # (Re)place
        self._update_piece_on_board()
        return result

    def remove_full_rows(self):
        '''
        Remove full rows and move partial rows down into the vacancies
        '''
        full_count = self.board.remove_full_rows()
        self._update_removed(full_count)
        self._set_rate()


class Config:
    '''
    Provide and save game configuration
    '''
    def __init__(self, test=False):
        '''
        Setup game configuration.  When ``test == True``, command line
        arguments are not processed
        '''
        self.test = test

        self.defaults = {
            'config_file': os.path.join(os.environ.get('HOME', ''), '.config/pysirtet/pysirtet.conf'),
            'debug': False,
            'board': {
                'scale': 32,  # [pixels/block] number of pixels per block side
                'width': 10,  # [blocks]
                'height': 22,  # [blocks]
            },
            'epsilon': sys.float_info.epsilon*3,  # Minimum float value allowed by game
            'initial_rate': 1,  # [blocks/second]
            'remove_freq': 2,  # Number of game cycles to wait to remove a row after it becomes full
            'constant': False,  # Do not increase game rate
            'shadow': 'projection',  # TODO: proposition
            'keys': {
                'pause': 'p',
                'left': ',',
                'right': '.',
                'left_side': 'z',
                'right_side': '/',
                'rotate_left': 'm',
                'rotate_right': 'v',
                'down': 'x',
                'drop': 'c',
            }
        }

    def _config_file(self, arg):
        '''
        Create the file if it does not exist and return the path
        '''
        if not os.path.exists(arg):
            path, file_name = os.path.split(arg)
            if not os.path.exists(path):
                os.makedirs(path)

        return arg

    def _size(self, arg):
        '''
        Validate size argument
        '''
        # Match data
        size_pattern = (r'(?P<width>\d+)'    # width pixels
                        r'(?P<mlt>[xX])'     # times
                        r'(?P<height>\d+)')  # height pixels
        match = re.match(size_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Construct return data and return
        board_size = {}
        for token in ('width', 'height'):
            value = match.group(token)
            board_size[token] = int(value) if value is not None else 0
        return board_size

    def _get_config(self, config_file):
        '''
        Read configs from config file
        '''
        # TODO: set opts equal to defaults, then override with config file values, then command line values
        opts = {}
        config = configparser.SafeConfigParser()
        config.read(config_file)

        # Internal configs
        opts['epsilon'] = self.defaults['epsilon']

        # Window configs
        opts['board'] = {}
        if config.has_section('board'):
            opts['board']['scale'] = config.get('board', 'scale', vars=self.defaults)
            opts['board']['width'] = config.get('board', 'width', vars=self.defaults)
            opts['board']['height'] = config.get('board', 'height', vars=self.defaults)
        else:
            opts['board']['scale'] = self.defaults['board']['scale']
            opts['board']['width'] = self.defaults['board']['width']
            opts['board']['height'] = self.defaults['board']['height']

        # Game configs
        if config.has_section('game'):
            opts['debug'] = config.get('game', 'debug', vars=self.defaults)
            opts['initial_rate'] = config.get('game', 'initial_rate', vars=self.defaults) or 1
            opts['constant'] = config.get('game', 'constant', vars=self.defaults)
            opts['remove_freq'] = config.get('game', 'remove_freq', vars=self.defaults)
            opts['shadow'] = config.get('game', 'shadow', vars=self.defaults)
        else:
            opts['debug'] = self.defaults['debug']
            opts['initial_rate'] = self.defaults['initial_rate']
            opts['constant'] = self.defaults['constant']
            opts['remove_freq'] = self.defaults['remove_freq']
            opts['shadow'] = self.defaults['shadow']

        # Keys configs
        opts['keys'] = {}
        if config.has_section('keys'):
            for key in opts['keys'].keys():
                opts['keys'][key] = config.get('keys', key, vars=self.defaults['keys'])
        else:
            opts['keys'] = self.defaults['keys']

        return opts

    def _get_args(self):
        '''
        Read configs from command line
        '''
        desc='Polyomino tessellation game written in Tkinter'
        arg_parser = ArgumentParser(description=desc,
                                    formatter_class=ArgumentDefaultsHelpFormatter)
        arg_parser.add_argument('-c', '--config-file',
                                default=self.defaults['config_file'],
                                type=self._config_file,
                                help='Specify location of the config file')
        arg_parser.add_argument('-d', '--debug',
                                default=self.defaults['debug'],
                                action='store_true',
                                help='Run game in debug mode')
        arg_parser.add_argument('-s', '--size',
                                default='{0[width]}x{0[height]}'.format(self.defaults['board']),
                                type=self._size,
                                help='Board size [blocks^2]')
        arg_parser.add_argument('-a', '--scale',
                                default=self.defaults['board']['scale'],
                                type=int,
                                help='Board scale [pixels/block]')
        arg_parser.add_argument('-r', '--initial-rate',
                                default=self.defaults['initial_rate'],
                                type=float,
                                help='Initial rate [blocks/second]')
        arg_parser.add_argument('-o', '--constant',
                                default=self.defaults['constant'],
                                action='store_true',
                                help='Do not increase game rate')
        return vars(arg_parser.parse_args())

    def get_opts(self):
        '''
        Setup program options
        '''
        # Config resolution:
        # 0. programmatic defaults
        # 1. dynamically set programmatic values
        # 2. config file values
        # 3. command line values
        args = self.defaults if self.test else self._get_args()
        opts = self._get_config(args['config_file'])
        opts.update(args)
        return opts

    def write_opts(self, opts):
        '''
        Save game configs to file when config dialog is closed
        '''
        # TODO


def pysirtet():
    '''
    Execute the game
    '''
    try:
        PySirtet(Config().get_opts(), master=tk.Tk(className='pysirtet')).mainloop()
    except KeyboardInterrupt:
        exit(0)


if __name__ == '__main__' : pysirtet()
