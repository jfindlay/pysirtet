#!/usr/bin/env python2

import re
import wx
import copy
import random
from argparse import ArgumentParser,ArgumentTypeError,ArgumentDefaultsHelpFormatter


class Polyomino(object):
    def __init__(self, name, coords, colors):
        self.name = name
        self.coords = coords
        self.colors = colors

    def x(self, index):
        return self.coords[index][0]

    def y(self, index):
        return self.coords[index][1]

    def set_x(self, index, x):
        self.coords[index][0] = x

    def set_y(self, index, y):
        self.coords[index][1] = y

    def min_x(self):
        return min([self.coords[i][0] for i in range(4)])

    def max_x(self):
        return max([self.coords[i][0] for i in range(4)])

    def min_y(self):
        return min([self.coords[i][1] for i in range(4)])

    def max_y(self):
        return max([self.coords[i][1] for i in range(4)])

    def rotated_left(self):
        result = Polyomino(self.name, copy.deepcopy(self.coords), self.colors)

        for i in range(4):
            result.set_x(i, self.y(i))
            result.set_y(i, -self.x(i))

        return result

    def rotated_right(self):
        result = Polyomino(self.name, copy.deepcopy(self.coords), self.colors)

        for i in range(4):
            result.set_x(i, -self.y(i))
            result.set_y(i, self.x(i))

        return result


tetrominoes = [
    Polyomino(
        name='Z',
        coords=[[0, -1], [0, 0], [-1, 0], [-1, 1]],
        colors={'normal': '#CC6666',
                'light' : '#F89FAB',
                'dark'  : '#803C3B'}
    ),
    Polyomino(
        name='S',
        coords=[[0, -1], [0, 0], [1, 0], [1, 1]],
        colors={'normal': '#66CC66',
                'light' : '#79FC79',
                'dark'  : '#3B803B'}
    ),
    Polyomino(
        name='l',
        coords=[[0, -1], [0, 0], [0, 1], [0, 2]],
        colors={'normal': '#6666CC',
                'light' : '#7979FC',
                'dark'  : '#3B3B80'}
    ),
    Polyomino(
        name='T',
        coords=[[-1, 0], [0, 0], [1, 0], [0, 1]],
        colors={'normal': '#CCCC66',
                'light' : '#FCFC79',
                'dark'  : '#80803B'}
    ),
    Polyomino(
        name='o',
        coords=[[0, 0], [1, 0], [0, 1], [1, 1]],
        colors={'normal': '#CC66CC',
                'light' : '#FC79FC',
                'dark'  : '#803B80'}
    ),
    Polyomino(
        name='L',
        coords=[[-1, -1], [0, -1], [0, 0], [0, 1]],
        colors={'normal': '#66CCCC',
                'light' : '#79FCFC',
                'dark'  : '#3B8080'}
    ),
    Polyomino(
        name='J',
        coords=[[1, -1], [0, -1], [0, 0], [0, 1]],
        colors={'normal': '#DAAA00',
                'light' : '#FCC600',
                'dark'  : '#806200'}
    ),
]


class PySirtet(wx.Frame):
    '''
    Main game window
    '''
    def __init__(self, opts):
        '''
        Setup game window
        '''
        # Create frame
        wx.Frame.__init__(self,
                          parent=None,
                          title='PySirtet',
                          size=(opts['geom']['wid'], opts['geom']['hei']))

        # Store program options
        self.opts = opts

        # Setup additional features and attributes of the game window
        self.status_bar = self.CreateStatusBar()

        self.board = Board(self, opts)
        self.board.SetFocus()
        self.board.start()

        self.Centre()
        self.Show(True)


class Board(wx.Panel):
    '''
    Game board
    '''
    ID_TIMER = 1

    def __init__(self, parent, opts):
        '''
        Setup board
        '''
        # Create panel
        wx.Panel.__init__(self, parent)

        # Store program options
        self.opts = opts

        # Setup additional features and attributes of the game board
        self.height = opts['height']
        self.width = opts['width']
        self.speed = opts['initial_speed']

        self.timer = wx.Timer(self, Board.ID_TIMER)
        self.cur_piece = self.random_piece()
        self.new_piece = self.random_piece()
        self.cur_x = 0
        self.cur_y = 0

        self.score = 0
        self.clear_board()
        self.update_status()

        self.is_started = False
        self.is_paused = False

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_TIMER, self.OnTimer, id=Board.ID_TIMER)

    def random_piece(self):
        '''
        Randomly choose a polyomino
        '''
        return random.choice(sorted(tetrominoes))

    def get_piece(self, name):
        '''
        Return the piece corresponding to the given name
        '''
        for tetromino in tetrominoes:
            if tetromino.name == name:
                return tetromino

    def clear_board(self):
        '''
        Setup and clear the board
        '''
        self.grid = [['' for i in range(self.height)] for j in range(self.width)]

    def update_status(self, state=''):
        '''
        Set status bar state
        '''
        # Get parent
        status_bar = self.GetParent().status_bar

        if state == 'paused':
            status_bar.SetStatusText('{} (Paused)'.format(self.score))
        elif state == 'over':
            status_bar.SetStatusText('{} (Game Over)'.format(self.score))
        else:
            status_bar.SetStatusText('{}'.format(self.score))

    def piece_at(self, x, y):
        '''
        Find the name of the polyomino piece occupying the grid position
        '''
        try:
            piece_name = self.grid[x][y]
        except IndexError:
            piece_name = 'L'
            for row in self.grid:
                row_str = ''
                for element in row:
                    row_str += ' ' if element == '' else element
                print('"{}" {}'.format(row_str, len(row_str)))
            print(len(self.grid), len(self.grid[0]), x, y)
            raise

        return piece_name

    def set_piece_at(self, x, y, piece_name):
        '''
        Set the name of the polyomino piece at the grid position
        '''
        self.grid[x][y] = piece_name

    def square_size(self):
        '''
        Return the size of a grid square
        '''
        width = self.GetClientSize().GetWidth()/self.width
        height = self.GetClientSize().GetHeight()/self.height

        return (width, height)

    def start(self):
        '''
        Start game
        '''
        if self.is_paused:
            return

        self.is_started = True
        self.score = 0
        self.clear_board()
        self.update_status()

        self.next_piece()
        self.timer.Start(self.speed)

    def pause(self):
        '''
        Pause game
        '''
        if not self.is_started:
            return

        self.is_paused = not self.is_paused

        if self.is_paused:
            self.timer.Stop()
            self.update_status('paused')
        else:
            self.timer.Start(self.speed)
            self.update_status()

        self.Refresh()

    def OnPaint(self, event):
        '''
        Paint event
        '''
        dc = wx.PaintDC(self)

        size = self.GetClientSize()
        square_width, square_height = self.square_size()
        board_top = size.GetHeight() - self.height*square_height

        for i in range(self.height):
            for j in range(self.width):
                piece_name = self.piece_at(j, self.height - i - 1)
                if piece_name != '':
                    self.draw_square(dc,
                        j*square_width,
                        board_top + i*square_height, self.get_piece(piece_name))

        if self.cur_piece.name != '':
            for i in range(4):
                x = self.cur_x + self.cur_piece.x(i)
                y = self.cur_y - self.cur_piece.y(i)
                self.draw_square(dc, x*square_width,
                    board_top + (self.height - y - 1)*square_height,
                    self.cur_piece)


    def OnKeyDown(self, event):
        '''
        Key input event
        '''
        if not self.is_started or self.cur_piece.name == '':
            event.Skip()
            return

        keycode = event.GetKeyCode()

        if keycode == ord('P') or keycode == ord('p'):
            self.pause()
            return
        if self.is_paused:
            return
        elif keycode == wx.WXK_LEFT:
            self.try_move(self.cur_piece, self.cur_x - 1, self.cur_y)
        elif keycode == wx.WXK_RIGHT:
            self.try_move(self.cur_piece, self.cur_x + 1, self.cur_y)
        elif keycode == wx.WXK_DOWN:
            self.try_move(self.cur_piece.rotated_right(), self.cur_x, self.cur_y)
        elif keycode == wx.WXK_UP:
            self.try_move(self.cur_piece.rotated_left(), self.cur_x, self.cur_y)
        elif keycode == wx.WXK_SPACE:
            self.drop_down()
        elif keycode == ord('D') or keycode == ord('d'):
            self.one_line_down()
        else:
            event.Skip()


    def OnTimer(self, event):
        '''
        Timer step event
        '''
        if event.GetId() == Board.ID_TIMER:
            self.one_line_down()
        else:
            event.Skip()


    def drop_down(self):
        '''
        Move current piece as far down as possible and introduce next piece
        '''
        new_y = self.cur_y

        while new_y > 0:
            if not self.try_move(self.cur_piece, self.cur_x, new_y - 1):
                break
            new_y -= 1

        self.piece_dropped()

    def one_line_down(self):
        '''
        Move current piece down one line
        '''
        if not self.try_move(self.cur_piece, self.cur_x, self.cur_y - 1):
            self.piece_dropped()

    def piece_dropped(self):
        '''
        Introduce new piece at the top of the board
        '''
        for i in range(4):
            x = self.cur_x + self.cur_piece.x(i)
            y = self.cur_y - self.cur_piece.y(i)
            self.set_piece_at(x, y, self.cur_piece.name)

        self.remove_full_lines()

        self.next_piece()


    def remove_full_lines(self):
        '''
        Remove a full line from the board
        '''
        num_full_lines = 0
        rows_to_remove = []

        # Collect full rows
        for i in range(self.height):
            n = sum([1 for j in range(self.width) if self.piece_at(j, i) != ''])
            if n == self.width:
                rows_to_remove.append(i)

        rows_to_remove.reverse()

        for m in rows_to_remove:
            # Remove full rows and move all above rows down
            for k in range(m, self.height):
                for l in range(self.width):
                    if k + 1 < self.height:
                        self.set_piece_at(l, k, self.piece_at(l, k + 1))
                    else:  # Top row
                        self.set_piece_at(l, k, '')

            num_full_lines += len(rows_to_remove)

            # Update game state
            if num_full_lines > 0:
                self.score = self.score + num_full_lines
                self.update_status()
                self.Refresh()


    def next_piece(self):
        '''
        Setup next piece
        '''
        # Cycle pieces
        self.cur_piece = self.new_piece
        self.new_piece = self.random_piece()

        # Update grid cursor
        self.cur_x = self.width/2 + 1
        self.cur_y = self.height - 1 + self.cur_piece.min_y()

        # Test halting condition
        if not self.try_move(self.cur_piece, self.cur_x, self.cur_y):
            self.timer.Stop()
            self.is_started = False
            self.update_status('over')

    def try_move(self, new_piece, new_x, new_y):
        '''
        Attempt to transform (translate, rotate) current piece
        '''
        for i in range(4):

            x = new_x + new_piece.x(i)
            y = new_y - new_piece.y(i)

            if x < 0 or x >= self.width or y < 0 or y >= self.height:
                return False
            if self.piece_at(x, y) != '':
                return False

        self.cur_piece = new_piece
        self.cur_x = new_x
        self.cur_y = new_y
        self.Refresh()

        return True


    def draw_square(self, dc, x, y, piece):
        '''
        Draw a square on the board
        '''
        # Get square size
        square_width, square_height = self.square_size()

        # Draw light edges
        pen = wx.Pen(piece.colors['light'])
        pen.SetCap(wx.CAP_PROJECTING)
        dc.SetPen(pen)

        dc.DrawLine(x, y + square_height - 1, x, y)
        dc.DrawLine(x, y, x + square_width - 1, y)

        # Draw dark edges
        darkpen = wx.Pen(piece.colors['dark'])
        darkpen.SetCap(wx.CAP_PROJECTING)
        dc.SetPen(darkpen)

        dc.DrawLine(x + 1, y + square_height - 1,
            x + square_width - 1, y + square_height - 1)
        dc.DrawLine(x + square_width - 1,
            y + square_height - 1, x + square_width - 1, y + 1)

        # Paint square surface
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(wx.Brush(piece.colors['normal']))
        dc.DrawRectangle(x + 1, y + 1, square_width - 2,
            square_height - 2)


def get_opts():
    '''
    Setup program options
    '''
    def geom(arg):
        '''
        Validate geometry argument
        '''
        # Match data
        geom_pattern = (r'(?P<wid>\d+)'         # width pixels
                        r'(?P<mlt>[xX])'        # times
                        r'(?P<hei>\d+)'         # height pixels
                        r'(?:'                  # optional non-capturing group for position
                            r'(?P<xsgn>[+-])*'  # x sign
                            r'(?P<xpos>\d+)*'   # x position
                            r'(?P<ysgn>[+-])*'  # y sign
                            r'(?P<ypos>\d+)*'   # y position
                        r')*')                  # close optional group
        match = re.match(geom_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Validate position
        extra = ('xsgn', 'xpos', 'ysgn', 'ypos')
        found_extra = [match.group(token) for token in extra]
        if any(found_extra) and not all(found_extra):
            raise ArgumentTypeError('Incorrect position')

        # Construct return data and return
        geom = {}
        for token in ('wid', 'hei', 'xpos', 'ypos'):
            value = match.group(token)
            geom[token] = int(value) if value is not None else 0
        for token in ('mlt', 'xsgn', 'ysgn'):
            value = match.group(token)
            geom[token] = value if value is not None else '+'
        return geom

    desc='Polyomino tessellation game written in wxPython'
    arg_parser = ArgumentParser(description=desc,
                                formatter_class=ArgumentDefaultsHelpFormatter)
    arg_parser.add_argument('-g', '--geometry',
                            dest='geom',
                            default='180x380',
                            type=geom,
                            help='Specify window geometry; see X(7) for info on'
                                 ' how to specify geometries')
    arg_parser.add_argument('-H', '--height',
                            default=22,
                            type=int,
                            help='Board height')
    arg_parser.add_argument('-W', '--width',
                            default=10,
                            type=int,
                            help='Board width')
    arg_parser.add_argument('-s', '--speed',
                            dest='initial_speed',
                            default=300,
                            type=int,
                            help='Initial game speed')
    arg_parser.add_argument('-c', '--constant',
                            action='store_true',
                            help='Maintain constant game speed')

    return vars(arg_parser.parse_args())


def pysirtet():
    '''
    Execute the game
    '''
    try:
        opts = get_opts()
        app = wx.App()
        PySirtet(opts)
        app.MainLoop()
    except KeyboardInterrupt:
        exit(0)


if __name__ == '__main__':
    pysirtet()
