#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Import python libs
import os
import re
import sys
import copy
import enum
import time
import random
import configparser
from argparse import ArgumentParser, ArgumentTypeError, ArgumentDefaultsHelpFormatter
import tkinter as tk


class Transformation(enum.Enum):
    cw = 0  # π/2 clockwise
    ccw = 1  # π/2 counterclockwise
    left = 2  # One column left
    right = 3  # One column right
    down = 4  # One row down
    min = 5  # Left side
    max = 6  # Right side
    bottom = 7  # Bottom side


class Polyomino:
    '''
    Define a polyomino by coordinates to the upper right corner of each of its
    squares and provide the valid transformations for a polyomino on the
    $\mathbb Z^2$ lattice
    '''
    def __init__(self, name, colors, coords, origin=[0, 0], ordinal=4):
        '''
        Setup attributes and coordinates
        '''
        self.name = name
        self.colors = colors
        self.ordinal = ordinal  # Polyomino ordinal (4 == tetromino, etc.)

        self.coords = coords  # Coordinates for each square in the polyomino
        self.o = origin  # Origin of the polyomino's proper reference frame relative to constraint frame

    def _check_constraints(self, r, constraints):
        '''
        Validate whether the coordinates r = (x, y), which correspond to the
        upper right corner of a polyomino square are allowed by the constraints
        '''
        # Check that r points to the interior of the grid
        try:
            constraints[r]
        except IndexError:
            return False
        # Only unoccupied grid squares are allowed
        if constraints[r] != None:
            return False

        return True

    def rotate(self, direction, constraints):
        '''
        Rotate polyomino clockwise or counterclockwise (±π/2) about its
        proper origin if the resulting transformation is contained within the
        constraints
        '''
        # Prepare new coordinates and rotation tensor
        coords = self.ordinal*[[]]
        sgn = direction.value  # +1 for ccw and -1 for cw

        # Apply rotation tensor if allowed
        for i, c in enumerate(self.x):
            coords[i][0] = -sgn*(self.coords[i][1] - self.o[1]) + self.o[0]
            coords[i][1] = sgn*(self.coords[i][0] - self.o[0]) + self.o[1]
            if not self._check_constraints(coords[i], constraints):
                return False

        # Set new coordinates
        self.coords = coords
        return True

    def translate(self, v, constraints):
        '''
        Translate polyomino by the vector v if the resulting transformation is
        contained within the constraints
        '''
        # Redefine v as explicit coordinates in the constraint reference frame
        if v[0] == Transformation.min:
            v = [-min(self.coords[0]), 0]
        elif v[0] == Transformation.max:
            v = [len(constraints) - max(self.coords[0]), 0]

        # Prepare new coordinates and new proper origin in the constraint frame
        coords = [[0, 0] for c in range(self.ordinal)]
        o = [self.o[0] + v[0], self.o[1] + v[1]]

        # Apply translation vector v if allowed
        for i, c in enumerate(self.coords):
            coords[i][0] = self.coords[i][0] + v[0]
            coords[i][1] = self.coords[i][1] + v[1]
            if not self._check_constraints(coords[i], constraints):
                return False

        # Set new coordinates and proper origin at translated position
        self.coords = coords
        self.o = o
        return True


class Tetrominoes(enum.Enum):
    Z = 1
    S = 2
    l = 3
    T = 4
    o = 5
    L = 6
    J = 7


tetromino_data = (
    Polyomino(
        name=Tetrominoes.Z,
        coords=[[-1, 1], [0, 1], [0, 0], [1, 0]],
        colors={'normal': '#CC6666',
                'light' : '#F89FAB',
                'dark'  : '#803C3B'}
    ),
    Polyomino(
        name=Tetrominoes.S,
        coords=[[-1, 0], [0, 0], [0, 1], [1, 1]],
        colors={'normal': '#66CC66',
                'light' : '#79FC79',
                'dark'  : '#3B803B'}
    ),
    Polyomino(
        name=Tetrominoes.l,
        coords=[[-2, 0], [-1, 0], [0, 0], [1, 0]],
        colors={'normal': '#6666CC',
                'light' : '#7979FC',
                'dark'  : '#3B3B80'}
    ),
    Polyomino(
        name=Tetrominoes.T,
        coords=[[-1, 1], [0, 1], [0, 0], [1, 1]],
        colors={'normal': '#CCCC66',
                'light' : '#FCFC79',
                'dark'  : '#80803B'}
    ),
    Polyomino(
        name=Tetrominoes.o,
        coords=[[-1, 1], [-1, 0], [0, 0], [0, 1]],
        colors={'normal': '#CC66CC',
                'light' : '#FC79FC',
                'dark'  : '#803B80'}
    ),
    Polyomino(
        name=Tetrominoes.L,
        coords=[[0, 2], [0, 1], [0, 0], [1, 0]],
        colors={'normal': '#66CCCC',
                'light' : '#79FCFC',
                'dark'  : '#3B8080'}
    ),
    Polyomino(
        name=Tetrominoes.J,
        coords=[[0, 2], [0, 1], [0, 0], [-1, 0]],
        colors={'normal': '#DAAA00',
                'light' : '#FCC600',
                'dark'  : '#806200'}
    ),
)


class Grid:
    '''
    The rectangular region of squares that comprises the game state.  The
    squares map to the integer coordinates in the first quadrant of the
    cartesian plane such that each square is represented by the (integral)
    point at its upper right corner.  The origin corresponds to the upper right
    corner of the lower left square of the grid
    '''
    def __init__(self, opts):
        '''
        Setup game grid
        '''
        # Store program options
        self.opts = opts

        # Initialize internal grid
        self._grid = [[None for i in range(self.opts['size']['height'])] for j in range(self.opts['size']['width'])]

    def __check_nonnegative(self, v):
        '''
        Disallow negative coordinates
        '''
        if 0 > min(v):
            raise IndexError('grid coordinates must be nonnegative')

    def __getitem__(self, v):
        '''
        Retrieve the square at coordinates v from the origin
        '''
        self.__check_nonnegative(v)
        return self._grid[v[0]][v[1]]

    def __setitem__(self, v, t):
        '''
        Update the square at coordinates v from the origin to be of tetromino type t
        '''
        self.__check_nonnegative(v)
        self._grid[v[0]][v[1]] = t

    def update(self, coords, t):
        '''
        Set the tetromino type at coords to be t
        '''
        for v in coords:
            self[v] = t

    def print(self):
        '''
        Display grid state
        '''
        # Convert columns to rows
        rows = len(self._grid[0])*['']
        for j, column in enumerate(self._grid):
            for i, element in enumerate(self._grid[j]):
                rows[i] += 2*(' ' if element is None else element.name)

        # Print rows with formatting
        digits = len(str(self.opts['size']['height']))
        row_fmt = '{{:0{}}}'.format(digits)
        print(digits*' ' + '+' + 2*len(self._grid)*'-' + '+')
        for i, row in enumerate(reversed(rows)):
            print(row_fmt.format(self.opts['size']['height'] - i - 1) + '|' + row + '|')
        print(digits*' ' + '+' + 2*len(self._grid)*'-' + '+')


class PySirtet(tk.Frame):
    '''
    Main game window
    '''
    def __init__(self, opts, master=None):
        '''
        Setup game window
        '''
        # Store program options
        self.opts = opts

        # Setup game state
        self.grid = Grid(self.opts)
        self.piece = None

        # Setup TK
        self.master = master
        super().__init__(master)
        self.pack()
        self.create_widgets()
        self.handle_events()
        self.iterate()

    def _get_loop_wait(self):
        '''
        Wait between game ticks [milliseconds]
        '''
        epsilon = sys.float_info.epsilon*4
        return round(1e3/(self.opts['speed'] if self.opts['speed'] > epsilon else epsilon))

    def handle_events(self):
        '''
        Respond to inputs and other game conditions, such as adding the next
        piece
        '''
        if self.piece == None:
            self.add_tetromino()
        self.master.after(0, self.handle_events)

    def iterate(self):
        '''
        Main loop of the game window
        '''
        if not self.move_piece(Transformation.down):  # Piece is stuck on the bottom
            time.sleep(self.opts['stick_wait'])
        self.grid.print()
        self.master.after(self._get_loop_wait(), self.iterate)

    def add_tetromino(self):
        '''
        Add a tetromino to the top center of the board
        '''
        # Get new piece
        new_name = random.choice(tuple(Tetrominoes))
        self.piece = copy.deepcopy([td for td in tetromino_data if td.name == new_name][0])
        # Translate piece to top center of board
        self.piece.translate([self.opts['size']['width']//2, self.opts['size']['height'] - 1 - max([c[1] for c in self.piece.coords])], self.grid)
        self.grid.update(self.piece.coords, self.piece.name)

    def move_piece(self, movement):
        '''
        Move current piece according to the movement requested:

        - (down) One row down
        - (left) One column left
        - (right) One column right
        - (bottom) To the lowest available position
        - (min) To the leftmost available position
        - (max) To the rightmost available position
        - (cw) Rotate π/2 clockwise about piece proper origin
        - (ccw) Rotate π/2 counterclockwise about piece proper origin
        '''
        # Map each movement to a predefined transformation on the current piece
        # (some movements need no parameters and are thus a passthrough to the
        # corresponding tetromino transformation)
        action = {
            Transformation.cw: (self.piece.rotate, movement),
            Transformation.ccw: (self.piece.rotate, movement),
            Transformation.left: (self.piece.translate, [-1, 0]),
            Transformation.right: (self.piece.translate, [1, 0]),
            Transformation.down: (self.piece.translate, [0, -1]),
            Transformation.min: (self.piece.translate, movement),
            Transformation.max: (self.piece.translate, movement),
            Transformation.bottom: (self.piece.translate, movement),
        }.get(movement)
        # Execute the transformation on the current piece in the grid if it is
        # allowed
        self.grid.update(self.piece.coords, None)  # Clear piece from previous location
        result = action[0](action[1], self.grid)
        self.grid.update(self.piece.coords, self.piece.name)  # Replace piece at new/same location
        return result

    def create_widgets(self):
        '''
        Pack in game widgets
        '''
        self.board = tk.Canvas(self,
                               width=self.opts['geometry']['width'],
                               height=self.opts['geometry']['height'])
        self.board.create_rectangle(0, 0,
                                    self.opts['geometry']['width'], self.opts['geometry']['height'],
                                    fill='black', width=0)
        self.board.pack(side="top")


def get_opts(test=False):
    '''
    Setup program options.  When ``test == True``, command line arguments are
    not processed
    '''
    defaults = {
        'config_file': os.path.join(os.environ.get('HOME', ''), '.config/pysirtet/pysirtet.conf'),
        'size': {'width': 10, 'height': 22},  # [blocks]
        'geometry_scale': 16,  # [pixels^2/blocks] Used to scale geometry size to the board size
        'geometry': '',  # The default geometry is set after the size is known
        'speed': 1,  # [blocks/second]
        'stick_wait': 1,  # [seconds] Wait time from when a piece bottoms out and a new piece is introduced
        'keys': {
            'pause': 'p',
            'left': ',',
            'right': '.',
            'left_side': 'z',
            'right_side': '/',
            'rotate_left': 'x',
            'rotate_right': 'c',
            'down': 'm',
            'drop': 'v',
        }
    }
    def default_geometry(size):
        '''
        Calculate the default geometry from the size
        '''
        return {'height': defaults['geometry_scale']*size['height'],
                'width': defaults['geometry_scale']*size['width']}

    def config_file(arg):
        '''
        Create the file if it does not exist and return the path
        '''
        if not os.path.exists(arg):
            path, file_name = os.path.split(arg)
            if not os.path.exists(path):
                os.makedirs(path)

        return arg

    def size(arg):
        '''
        Validate size argument
        '''
        # Match data
        size_pattern = (r'(?P<width>\d+)'    # width pixels
                        r'(?P<mlt>[xX])'     # times
                        r'(?P<height>\d+)')  # height pixels
        match = re.match(size_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Construct return data and return
        geometry = {}
        for token in ('width', 'height'):
            value = match.group(token)
            geometry[token] = int(value) if value is not None else 0
        return geometry

    def geometry(arg):
        '''
        Validate geometry argument
        '''
        # Match data
        geom_pattern = (r'(?P<width>\d+)'       # width pixels
                        r'(?P<mlt>[xX])'        # times
                        r'(?P<height>\d+)'      # height pixels
                        r'(?:'                  # optional non-capturing group for position
                            r'(?P<xsgn>[+-])*'  # x sign
                            r'(?P<xpos>\d+)*'   # x position
                            r'(?P<ysgn>[+-])*'  # y sign
                            r'(?P<ypos>\d+)*'   # y position
                        r')*')                  # close optional group
        match = re.match(geom_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Validate position
        extra = ('xsgn', 'xpos', 'ysgn', 'ypos')
        found_extra = [match.group(token) for token in extra]
        if any(found_extra) and not all(found_extra):
            raise ArgumentTypeError('Incorrect position')

        # Construct return data and return
        geometry = {}
        for token in ('width', 'height', 'xpos', 'ypos'):
            value = match.group(token)
            geometry[token] = int(value) if value is not None else 0
        for token in ('xsgn', 'ysgn'):
            value = match.group(token)
            geometry[token] = value if value is not None else '+'
        return geometry

    def get_config(config_file):
        '''
        Read configs from config file
        '''
        opts = {}
        config = configparser.SafeConfigParser()
        config.read(config_file)

        # Window configs
        if config.has_section('window'):
            opts['size'] = config.get('window', 'size', vars=defaults)
            opts['geometry'] = config.get('window', 'geometry', vars={'geometry': default_geometry(opts['size'])})
        else:
            opts['size'] = defaults['size']
            opts['geometry'] = default_geometry(defaults['size'])

        # Game configs
        if config.has_section('game'):
            opts['speed'] = config.get('game', 'speed', vars=defaults)
            opts['stick_wait'] = config.get('game', 'stick_wait', vars=defaults)
        else:
            opts['speed'] = defaults['speed']
            opts['stick_wait'] = defaults['stick_wait']

        # Keys configs
        if config.has_section('keys'):
            opts['keys'] = {}
            for key in opts['keys'].keys():
                opts['keys'][key] = config.get('keys', key, vars=defaults['keys'])
        else:
            opts['keys'] = defaults['keys']

        return opts

    def get_args():
        '''
        Read configs from command line
        '''
        desc='Polyomino tessellation game written in tkinter'
        arg_parser = ArgumentParser(description=desc,
                                    formatter_class=ArgumentDefaultsHelpFormatter)
        arg_parser.add_argument('-c', '--config-file',
                                default=defaults['config_file'],
                                type=config_file,
                                help='Specify location of the config file')
        arg_parser.add_argument('-s', '--size',
                                default='{0[width]}x{0[height]}'.format(defaults['size']),
                                type=size,
                                help='Board size')
        arg_parser.add_argument('-g', '--geometry',
                                default='{0[width]}x{0[height]}'.format(default_geometry(defaults['size'])),
                                dest='geometry',
                                type=geometry,
                                help='Specify window geometry; see X(7) for info on'
                                     ' how to specify geometries')
        arg_parser.add_argument('-S', '--speed',
                                default=defaults['speed'],
                                type=float,
                                help='Game speed [blocks/second]; if set, the game will run'
                                     ' constantly at this speed regardless of the'
                                     ' number of removed rows')
        return vars(arg_parser.parse_args())

    # Load configs from command line
    args = defaults if test else get_args()

    # Load configs from config file
    opts = get_config(args['config_file'])

    # Default window size to a scale factor of the board size
    if args['size'] != defaults['size']:
        if (args['geometry']['width'] == default_geometry(defaults['size'])['width']
        and args['geometry']['height'] == default_geometry(defaults['size'])['height']):
            args['geometry'].update(default_geometry(args['size']))

    # Override configs with values from command line
    opts.update(args)

    return opts


def write_config(opts):
    '''
    Save game configs to file when config dialog is closed
    '''
    # TODO


def pysirtet():
    '''
    Execute the game
    '''
    try:
        PySirtet(get_opts(), master=tk.Tk()).mainloop()
    except KeyboardInterrupt:
        exit(0)


if __name__ == '__main__' : pysirtet()
