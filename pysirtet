#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Import python libs
import os
import re
import sys
import math
import copy
import enum
import time
import random
import configparser
from argparse import ArgumentParser, ArgumentTypeError, ArgumentDefaultsHelpFormatter
import tkinter as tk


class Transformation(enum.Enum):
    identity = 0
    # Rotations
    cw = 1  # π/2 clockwise
    ccw = 2  # π/2 counterclockwise
    # Single row/column translations
    left = 3  # One column left
    right = 4  # One column right
    down = 5  # One row down
    # Extremal translations
    min = 6  # Left side
    max = 7  # Right side
    bottom = 8  # Bottom side


class Polyomino:
    '''
    Define a polyomino by coordinates to the upper right corner of each of its
    squares and provide the valid transformations for a polyomino on the
    $\mathbb Z^2$ lattice
    '''
    def __init__(self, name, colors, coords, origin=[0, 0]):
        '''
        Setup attributes and coordinates
        '''
        self.name = name
        self.colors = colors

        self.coords = coords  # Coordinates for each square in the polyomino
        self.ordinal = len(self.coords)  # Polyomino ordinal (4 == tetromino, etc.)
        self.o = origin  # Origin of the polyomino's proper reference frame relative to grid frame

    def _check_grid(self, coords, grid):
        '''
        Validate whether the coordinates, which correspond to the upper right
        corner of a polyomino square are all available in the grid
        '''
        for r in coords:
            # Check that r points to the interior of the grid
            try:
                grid[r]
            except IndexError:
                return False
            # Check that r points to an unoccupied square
            if grid[r]['type'] != None:
                return False
        return True

    def _min(self, dimension):
        '''
        Return the minimum coordinate of the polyomino in the given dimension
        ('x' corresponds to 0 and 'y' to 1)
        '''
        return min([c[dimension] for c in self.coords])

    def _max(self, dimension):
        '''
        Return the maximum coordinate of the polyomino in the given dimension
        ('x' corresponds to 0 and 'y' to 1)
        '''
        return max([c[dimension] for c in self.coords])

    def rotate(self, direction, grid, **kwargs):
        '''
        Rotate polyomino clockwise or counterclockwise (±π/2) about its
        proper origin if the resulting transformation is contained within the
        grid
        '''
        # Prepare new coordinates and rotation tensor
        coords = [[0, 0] for i in range(self.ordinal)]
        sgn = {
            Transformation.cw: -1,
            Transformation.ccw: 1,
        }.get(direction)

        # Apply rotation tensor if possible
        for i in range(self.ordinal):
            coords[i][0] = -sgn*(self.coords[i][1] - self.o[1]) + self.o[0]
            coords[i][1] = sgn*(self.coords[i][0] - self.o[0]) + self.o[1]
        if self._check_grid(coords, grid):
            self.coords = coords
            return True
        return False

    def translate(self, v, grid, incremental=False):
        '''
        Translate polyomino by the vector v if the resulting transformation
        places the polyomino within the grid and on unoccupied squares
        '''
        # Redefine v as explicit coordinates in the grid reference frame and
        # define eigenform of v
        if v == Transformation.min:
            v = [-self._min(0), 0]
        elif v == Transformation.max:
            v = [grid.width - self._max(0) - 1, 0]
        elif v == Transformation.bottom:
            v = [0, -self._min(1)]
        magnitude = math.sqrt(v[0]**2 + v[1]**2) or 1  # Prevent zero division
        eigen = [math.ceil(v[0]/magnitude), math.ceil(v[1]/magnitude)]

        # Prepare new coordinates and new proper origin in the grid frame
        coords = [[0, 0] for i in range(self.ordinal)]
        o = [0, 0]

        # Incrementally apply upto translation vector v
        success = None
        u = eigen if incremental else v
        while True:
            for i in range(self.ordinal):
                coords[i][0] = self.coords[i][0] + u[0]
                coords[i][1] = self.coords[i][1] + u[1]
                o = [self.o[0] + u[0], self.o[1] + u[1]]
            if self._check_grid(coords, grid):
                self.coords = [[coord[0], coord[1]] for coord in coords]
                self.o = [o[0], o[1]]
                success = True
                if not incremental:
                    return success
            else:
                return success


class TetrominoName(enum.Enum):
    Z = 1
    S = 2
    l = 3
    T = 4
    o = 5
    L = 6
    J = 7


tetrominoes = (
    Polyomino(
        name=TetrominoName.Z,
        coords=[[-1, 1], [0, 1], [0, 0], [1, 0]],
        colors={'normal': '#CC6666',
                'light' : '#F89FAB',
                'dark'  : '#803C3B'},
    ),
    Polyomino(
        name=TetrominoName.S,
        coords=[[-1, 0], [0, 0], [0, 1], [1, 1]],
        colors={'normal': '#66CC66',
                'light' : '#79FC79',
                'dark'  : '#3B803B'},
    ),
    Polyomino(
        name=TetrominoName.l,
        coords=[[-2, 0], [-1, 0], [0, 0], [1, 0]],
        colors={'normal': '#6666CC',
                'light' : '#7979FC',
                'dark'  : '#3B3B80'},
    ),
    Polyomino(
        name=TetrominoName.T,
        coords=[[-1, 1], [0, 1], [0, 0], [1, 1]],
        colors={'normal': '#CCCC66',
                'light' : '#FCFC79',
                'dark'  : '#80803B'},
    ),
    Polyomino(
        name=TetrominoName.o,
        coords=[[-1, 1], [-1, 0], [0, 0], [0, 1]],
        colors={'normal': '#CC66CC',
                'light' : '#FC79FC',
                'dark'  : '#803B80'},
    ),
    Polyomino(
        name=TetrominoName.L,
        coords=[[0, 2], [0, 1], [0, 0], [1, 0]],
        colors={'normal': '#66CCCC',
                'light' : '#79FCFC',
                'dark'  : '#3B8080'},
    ),
    Polyomino(
        name=TetrominoName.J,
        coords=[[0, 2], [0, 1], [0, 0], [-1, 0]],
        colors={'normal': '#DAAA00',
                'light' : '#FCC600',
                'dark'  : '#806200'},
    ),
)


class Grid:
    '''
    The rectangular region of squares that comprises the game state.  The
    squares map to the integer coordinates in the first quadrant of the
    cartesian plane such that each square is represented by the (integral)
    point at its upper right corner.  The origin corresponds to the upper right
    corner of the lower left square of the grid
    '''
    def __init__(self, opts):
        '''
        Setup game grid
        '''
        # Store program options
        self.opts = opts

        # Initialize internal grid
        self._grid = [[{'type': None, 'id': None} for i in range(self.opts['size']['height'])] for j in range(self.opts['size']['width'])]
        self.width = len(self._grid)
        self.height = len(self._grid[0])

    def __check_nonnegative(self, v):
        '''
        Disallow accessing squares by negative coordinates.  Python allows
        accessing elements of iterables by one modulus below the residual
        representation of the array, but we disallow it for simplicity
        '''
        if 0 > min(v):
            raise IndexError('grid coordinates must be nonnegative')

    def __getitem__(self, v):
        '''
        Retrieve the square details at coordinates v from the origin
        '''
        self.__check_nonnegative(v)
        return self._grid[v[0]][v[1]]

    def __setitem__(self, v, d):
        '''
        Update the square at coordinates v from the origin to be of tetromino
        type t with Tkinter item id i, where d is a dictionary of the form
        {'type': t, 'id': i)
        '''
        self.__check_nonnegative(v)
        self._grid[v[0]][v[1]].update(d)

    def __iter__(self):
        '''
        Iterate over the grid squares, providing both the coordinates and the
        square info
        '''
        for x in range(self.width):
            for y in range(self.height):
                yield (x, y), self[x, y]

    def print(self):
        '''
        Display grid state
        '''
        # Convert columns to rows
        rows = {}
        for v, square in self:
            if not v[1] in rows:
                rows[v[1]] = {}
            rows[v[1]][v[0]] = ' ' if square['type'] is None else square['type'].name
        for i, row in enumerate(rows):
            rows[i] = ''.join([2*rows[i][j] for j in sorted(rows[i].keys())])

        # Print rows with formatting
        digits = len(str(self.opts['size']['height']))
        row_fmt = '{{:0{}}}'.format(digits)
        print(digits*' ' + '+' + 2*len(self._grid)*'-' + '+')
        for i in reversed(list(rows.keys())):
            print(row_fmt.format(self.opts['size']['height'] - i - 1) + '|' + rows[i] + '|')
        print(digits*' ' + '+' + 2*len(self._grid)*'-' + '+')


class PySirtet(tk.Frame):
    '''
    Main game window
    '''
    def __init__(self, opts, master=None):
        '''
        Setup game window
        '''
        # Setup options
        self.opts = opts
        self.scale = self.opts['scale']
        self.width = self.scale*self.opts['size']['width']
        self.height = self.scale*self.opts['size']['height']
        self.thickness = self.scale//16

        # Setup game state
        self.grid = Grid(self.opts)
        self.piece = None
        self.paused = None

        # Setup TK
        self.master = master
        super().__init__(master)
        self.pack()
        self.setup_events()
        self.create_widgets()
        self.add_piece()
        self.iterate_id = self.master.after(self._get_loop_wait(), self.iterate)

    def _get_loop_wait(self):
        '''
        Wait between game ticks [milliseconds]
        '''
        epsilon = sys.float_info.epsilon*3
        return round(1e3/(self.opts['speed'] if self.opts['speed'] > epsilon else epsilon))

    def setup_events(self):
        '''
        Respond to inputs and other game conditions: mainly key input
        '''
        for name, key in self.opts['keys'].items():
            self.master.bind(key, getattr(self, name))

    def pause(self, event):
        '''
        (Un)pause the game
        '''
        if self.paused:
            self.iterate_id = self.master.after(self._get_loop_wait(), self.iterate)
            self.paused = False
        else:
            self.after_cancel(self.iterate_id)
            self.paused = True

    def move(transformation):
        '''
        Map keys to transformations on the current piece
        '''
        def transform(self, event):
            '''
            Transform the current piece
            '''
            self.move_piece(transformation)
        return transform

    left = move(Transformation.left)
    right = move(Transformation.right)
    left_side = move(Transformation.min)
    right_side = move(Transformation.max)
    rotate_left = move(Transformation.ccw)
    rotate_right = move(Transformation.cw)
    down = move(Transformation.down)
    drop = move(Transformation.bottom)

    def iterate(self):
        '''
        Move the active piece one row down
        '''
        if not self.move_piece(Transformation.down):
            time.sleep(self.opts['stick_wait'])
            self.remove_rows()
            self.add_piece()
        if self.opts['debug']:
            self.grid.print()
        self.iterate_id = self.master.after(self._get_loop_wait(), self.iterate)

    def add_piece(self):
        '''
        Add a tetromino to the top center of the grid
        '''
        new_name = random.choice(tuple(TetrominoName))
        self.piece = copy.deepcopy([td for td in tetrominoes if td.name == new_name][0])
        if not self.piece.translate([self.opts['size']['width']//2, self.opts['size']['height'] - 1 - max([c[1] for c in self.piece.coords])], self.grid):
            pass  # Game Over
        self._update_grid(self.piece)

    def move_piece(self, movement):
        '''
        Move current piece according to the movement requested:

        - (down) One row down
        - (left) One column left
        - (right) One column right
        - (bottom) To the lowest available position
        - (min) To the leftmost available position
        - (max) To the rightmost available position
        - (cw) Rotate π/2 clockwise about piece proper origin
        - (ccw) Rotate π/2 counterclockwise about piece proper origin
        '''
        # Map each movement to a predefined transformation on the current piece
        transform, magnitude, kwargs = {
            Transformation.cw: (self.piece.rotate, movement, {}),
            Transformation.ccw: (self.piece.rotate, movement, {}),
            Transformation.left: (self.piece.translate, [-1, 0], {}),
            Transformation.right: (self.piece.translate, [1, 0], {}),
            Transformation.down: (self.piece.translate, [0, -1], {}),
            Transformation.min: (self.piece.translate, movement, {'incremental': True}),
            Transformation.max: (self.piece.translate, movement, {'incremental': True}),
            Transformation.bottom: (self.piece.translate, movement, {'incremental': True}),
        }.get(movement)
        # Execute the transformation on the current piece if possible
        self._update_grid(self.piece, clear=True)
        result = transform(magnitude, self.grid, **kwargs)
        self._update_grid(self.piece)  # (Re)place
        return result

    def remove_rows(self):
        '''
        Remove any full rows
        '''

    def _update_grid(self, piece, clear=False):
        '''
        Place or clear piece on the grid
        '''
        for v in piece.coords:
            square = self.grid[v]
            if clear:
                square.update({'type': None, 'id': self.board.delete(square['id'])})
            else:
                square.update({'type': piece.name, 'id': self._draw_square(v, piece.colors)})

    def _transform_coord(self, v):
        '''
        pysirtet treats the game board as the first quadrant of the Cartesian
        plane with the origin at the lower left corner, whereas Tkinter,
        conventionally, places the origin in the upper left corner, with
        positive x and y directions pointing right and down, respectively
        '''
        return [v[0], self.opts['size']['height'] - 1 - v[1]]

    def _draw_square(self, v, colors):
        '''
        Draw or clear a polyomino square on the board at v
        '''
        u = self._transform_coord(v)
        return self.board.create_rectangle(self.scale*u[0] + self.thickness,
                                           self.scale*u[1] + self.thickness,
                                           self.scale*(u[0] + 1),
                                           self.scale*(u[1] + 1),
                                           fill=colors['normal'],
                                           outline=colors['dark'],
                                           width=self.thickness)

    def _draw_board(self):
        '''
        Draw the game board
        '''
        board = tk.Canvas(self, width=self.width, height=self.height)
        board.create_rectangle(0, 0,
                               self.width, self.height,
                               fill='black',
                               outline='black',
                               width=self.thickness)

        if self.opts['debug']:
            for v, square in self.grid:
                u = self._transform_coord(v)
                board.create_text((self.scale*u[0], self.scale*u[1]),
                                  text='{},{}'.format(*v),
                                  fill='white', font=('Monospace', 5), anchor=tk.NW)

        return board

    def create_widgets(self):
        '''
        Pack in game widgets
        '''
        self.board = self._draw_board()
        self.board.pack(side="top")


class Config:
    '''
    Provide and save game configuration
    '''
    def __init__(self, test=False):
        '''
        Setup game configuration.  When ``test == True``, command line
        arguments are not processed
        '''
        self.test = test

        self.defaults = {
            'config_file': os.path.join(os.environ.get('HOME', ''), '.config/pysirtet/pysirtet.conf'),
            'debug': False,
            'size': {'width': 10, 'height': 22},  # [blocks]
            'scale': 32,  # [pixels/block] number of pixels per block side
            'speed': 1,  # [blocks/second]
            'constant': False,  # Do not increase game speed
            'stick_wait': 1,  # [seconds] Wait time from when a piece bottoms out and a new piece is introduced
            'keys': {
                'pause': 'p',
                'left': ',',
                'right': '.',
                'left_side': 'z',
                'right_side': '/',
                'rotate_left': 'v',
                'rotate_right': 'm',
                'down': 'x',
                'drop': 'c',
            }
        }

    def _config_file(self, arg):
        '''
        Create the file if it does not exist and return the path
        '''
        if not os.path.exists(arg):
            path, file_name = os.path.split(arg)
            if not os.path.exists(path):
                os.makedirs(path)

        return arg

    def _size(self, arg):
        '''
        Validate size argument
        '''
        # Match data
        size_pattern = (r'(?P<width>\d+)'    # width pixels
                        r'(?P<mlt>[xX])'     # times
                        r'(?P<height>\d+)')  # height pixels
        match = re.match(size_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Construct return data and return
        grid_size = {}
        for token in ('width', 'height'):
            value = match.group(token)
            grid_size[token] = int(value) if value is not None else 0
        return grid_size

    def _get_config(self, config_file):
        '''
        Read configs from config file
        '''
        opts = {}
        config = configparser.SafeConfigParser()
        config.read(config_file)

        # Window configs
        if config.has_section('grid'):
            opts['size'] = config.get('grid', 'size', vars=self.defaults)
            opts['scale'] = config.get('grid', 'scale', vars=self.defaults)
        else:
            opts['size'] = self.defaults['size']
            opts['scale'] = self.defaults['scale']

        # Game configs
        if config.has_section('game'):
            opts['debug'] = config.get('game', 'debug', vars=self.defaults)
            opts['speed'] = config.get('game', 'speed', vars=self.defaults)
            opts['constant'] = config.get('game', 'constant', vars=self.defaults)
            opts['stick_wait'] = config.get('game', 'stick_wait', vars=self.defaults)
        else:
            opts['speed'] = self.defaults['speed']
            opts['constant'] = self.defaults['constant']
            opts['stick_wait'] = self.defaults['stick_wait']

        # Keys configs
        if config.has_section('keys'):
            opts['keys'] = {}
            for key in opts['keys'].keys():
                opts['keys'][key] = config.get('keys', key, vars=self.defaults['keys'])
        else:
            opts['keys'] = self.defaults['keys']

        return opts

    def _get_args(self):
        '''
        Read configs from command line
        '''
        desc='Polyomino tessellation game written in Tkinter'
        arg_parser = ArgumentParser(description=desc,
                                    formatter_class=ArgumentDefaultsHelpFormatter)
        arg_parser.add_argument('-c', '--config-file',
                                default=self.defaults['config_file'],
                                type=self._config_file,
                                help='Specify location of the config file')
        arg_parser.add_argument('-d', '--debug',
                                default=self.defaults['debug'],
                                action='store_true',
                                help='Run game in debug mode')
        arg_parser.add_argument('-s', '--size',
                                default='{0[width]}x{0[height]}'.format(self.defaults['size']),
                                type=self._size,
                                help='Board size [blocks^2]')
        arg_parser.add_argument('-a', '--scale',
                                default=self.defaults['scale'],
                                type=int,
                                help='Board scale [pixels/block]')
        arg_parser.add_argument('-S', '--speed',
                                default=self.defaults['speed'],
                                type=float,
                                help='Starting speed [blocks/second]')
        arg_parser.add_argument('-o', '--constant',
                                default=self.defaults['constant'],
                                action='store_true',
                                help='Do not increase game speed')
        return vars(arg_parser.parse_args())

    def get_opts(self):
        '''
        Setup program options
        '''
        # Override configs with values from command line
        args = self.defaults if self.test else self._get_args()
        opts = self._get_config(args['config_file'])
        opts.update(args)
        return opts

    def write_opts(self, opts):
        '''
        Save game configs to file when config dialog is closed
        '''
        # TODO


def pysirtet():
    '''
    Execute the game
    '''
    try:
        PySirtet(Config().get_opts(), master=tk.Tk()).mainloop()
    except KeyboardInterrupt:
        exit(0)


if __name__ == '__main__' : pysirtet()
