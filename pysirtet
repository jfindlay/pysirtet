#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Import python libs
import os
import re
import sys
import math
import copy
import enum
import time
import random
import configparser
from decimal import Decimal as D
from argparse import ArgumentParser, ArgumentTypeError, ArgumentDefaultsHelpFormatter
import tkinter as tk


class Transformation(enum.Enum):
    identity = 0
    # Rotations
    cw = 1  # π/2 clockwise
    ccw = 2  # π/2 counterclockwise
    # Single row/column translations
    left = 3  # One column left
    right = 4  # One column right
    down = 5  # One row down
    # Extremal translations
    min = 6  # Left side
    max = 7  # Right side
    bottom = 8  # Bottom side


class Polyomino:
    '''
    Define a polyomino by coordinates to the upper right corner of each of its
    squares and provide the valid transformations for a polyomino on the
    $\mathbb Z^2$ lattice
    '''
    def __init__(self, name, colors, coords):
        '''
        Setup attributes and coordinates
        '''
        self.name = name
        self.colors = colors

        # To minimize the distance between the polyomino proper origin and the
        # polyomino center of mass, coordinates can take integral and
        # half-integral values
        if any([v[0]%1 or v[1]%1 for v in coords]):
            self.coords = [[int(v[0] + D('-0.5')), int(v[1] + D('-0.5'))] for v in coords]
            self.o = [D('-0.5'), D('-0.5')]
        else:
            self.coords = coords
            self.o = [0, 0]
        self.ordinal = len(coords)  # Polyomino ordinal (4 == tetromino, etc.)

    def _check_grid(self, coords, grid):
        '''
        Validate whether the coordinates, which correspond to the upper right
        corner of a polyomino square are all available in the grid
        '''
        for v in coords:
            # Check that v points to the interior of the grid
            try:
                grid[v]
            except IndexError:
                return False
            # Check that v points to an unoccupied square
            if grid[v]['type'] != None:
                return False
        return True

    def min(self, dimension):
        '''
        Return the minimum coordinate of the polyomino in the given dimension
        ('x' corresponds to 0 and 'y' to 1)
        '''
        return min([c[dimension] for c in self.coords])

    def max(self, dimension):
        '''
        Return the maximum coordinate of the polyomino in the given dimension
        ('x' corresponds to 0 and 'y' to 1)
        '''
        return max([c[dimension] for c in self.coords])

    def rotate(self, direction, grid, **kwargs):
        '''
        Rotate polyomino clockwise or counterclockwise (±π/2) about its proper
        origin if the resulting transformation is contained within the grid and
        places the polyomino on unoccupied squares
        '''
        # Prepare new coordinates and rotation tensor
        coords = [[0, 0] for i in range(self.ordinal)]
        sgn = {
            Transformation.cw: -1,
            Transformation.ccw: 1,
        }.get(direction)

        # Apply rotation tensor if possible
        for i in range(self.ordinal):
            coords[i][0] = int(-sgn*(self.coords[i][1] - self.o[1]) + self.o[0])
            coords[i][1] = int(sgn*(self.coords[i][0] - self.o[0]) + self.o[1])
        if self._check_grid(coords, grid):
            self.coords = coords
            return True
        return False

    def translate(self, v, grid, incremental=False):
        '''
        Translate polyomino by the vector v if the resulting transformation
        places the polyomino within the grid and on unoccupied squares

        :param incremental: If true, move the polyomino one row/column at a
        time in the direction of v
        '''
        # Redefine v as explicit coordinates in the grid reference frame
        if isinstance(v, Transformation):
            v = {
                Transformation.left: [-1, 0],
                Transformation.right: [1, 0],
                Transformation.down: [0, -1],
                Transformation.min: [-self.min(0), 0],
                Transformation.max: [grid.width - self.max(0) - 1, 0],
                Transformation.bottom: [0, -self.min(1)],
            }.get(v)
        # define unit form of v
        magnitude = D(math.sqrt(v[0]**2 + v[1]**2)) or 1  # Prevent zero division
        unit = [math.ceil(v[0]/magnitude), math.ceil(v[1]/magnitude)]

        # Prepare new coordinates and new proper origin in the grid frame
        coords = [[0, 0] for i in range(self.ordinal)]
        o = [0, 0]

        # Incrementally apply upto translation vector v
        success = None
        u = unit if incremental else v
        if u == [0, 0]:
            return success
        while True:
            for i in range(self.ordinal):
                coords[i][0] = self.coords[i][0] + u[0]
                coords[i][1] = self.coords[i][1] + u[1]
                o = [self.o[0] + u[0], self.o[1] + u[1]]
            if self._check_grid(coords, grid):
                self.coords = [[coord[0], coord[1]] for coord in coords]
                self.o = [o[0], o[1]]
                success = True
                if not incremental:
                    return success
            else:
                return success


tetrominoes = (
    Polyomino(
        name='Z',
        coords=[[-1, 1], [0, 1], [0, 0], [1, 0]],
        colors={'normal': '#CC6666',
                'light' : '#F89FAB',
                'dark'  : '#803C3B'},
    ),
    Polyomino(
        name='S',
        coords=[[-1, 0], [0, 0], [0, 1], [1, 1]],
        colors={'normal': '#66CC66',
                'light' : '#79FC79',
                'dark'  : '#3B803B'},
    ),
    Polyomino(
        name='l',
        coords=[[D('-1.5'), D('-0.5')], [D('-0.5'), D('-0.5')], [D('0.5'), D('-0.5')], [D('1.5'), D('-0.5')]],
        colors={'normal': '#6666CC',
                'light' : '#7979FC',
                'dark'  : '#3B3B80'},
    ),
    Polyomino(
        name='T',
        coords=[[-1, 0], [0, 0], [0, -1], [1, 0]],
        colors={'normal': '#CCCC66',
                'light' : '#FCFC79',
                'dark'  : '#80803B'},
    ),
    Polyomino(
        name='o',
        coords=[[D('-0.5'), D('0.5')], [D('-0.5'), D('-0.5')], [D('0.5'), D('0.5')], [D('0.5'), D('-0.5')]],
        colors={'normal': '#CC66CC',
                'light' : '#FC79FC',
                'dark'  : '#803B80'},
    ),
    Polyomino(
        name='L',
        coords=[[0, 1], [0, 0], [0, -1], [1, -1]],
        colors={'normal': '#66CCCC',
                'light' : '#79FCFC',
                'dark'  : '#3B8080'},
    ),
    Polyomino(
        name='J',
        coords=[[0, 1], [0, 0], [0, -1], [-1, -1]],
        colors={'normal': '#DAAA00',
                'light' : '#FCC600',
                'dark'  : '#806200'},
    ),
)


class Grid:
    '''
    The rectangular region of squares that comprises the game state.  The
    squares map to the integer coordinates in the first quadrant of the
    cartesian plane such that each square is represented by the (integral)
    point at its upper right corner.  The origin corresponds to the upper right
    corner of the lower left square of the grid
    '''
    def __init__(self, opts):
        '''
        Setup game grid
        '''
        # Store program options
        self.opts = opts

        # Initialize internal grid
        self._grid = [[{'type': None, 'id': None, 'colors': {}} for i in range(self.opts['board']['size']['height'])] for j in range(self.opts['board']['size']['width'])]
        self.width = len(self._grid)
        self.height = len(self._grid[0])

    def __check_nonnegative(self, v):
        '''
        Disallow accessing squares by negative coordinates.  Python allows
        accessing elements of iterables by one modulus below the residual
        representation of the array, but we disallow it for simplicity
        '''
        if 0 > min(v):
            raise IndexError('grid coordinates must be nonnegative')

    def __getitem__(self, v):
        '''
        Retrieve the square details at coordinates v from the origin
        '''
        self.__check_nonnegative(v)
        return self._grid[v[0]][v[1]]

    def __setitem__(self, v, d):
        '''
        Update the square at coordinates v from the origin to be of tetromino
        type t with Tkinter item id i, where d is a dictionary of the form
        {'type': t, 'id': i)
        '''
        self.__check_nonnegative(v)
        self._grid[v[0]][v[1]].update(d)

    def __iter__(self):
        '''
        Iterate over the grid squares, providing both the coordinates and the
        square info
        '''
        for x in range(self.width):
            for y in range(self.height):
                yield (x, y), self[x, y]

    def print(self):
        '''
        Display grid state
        '''
        # Convert columns to rows
        rows = {}
        for v, square in self:
            if not v[1] in rows:
                rows[v[1]] = {}
            rows[v[1]][v[0]] = ' ' if square['type'] is None else square['type'].name
        for i, row in enumerate(rows):
            rows[i] = ''.join([2*rows[i][j] for j in sorted(rows[i].keys())])

        # Print rows with formatting
        digits = len(str(self.opts['size']['height']))
        row_fmt = '{{:0{}}}'.format(digits)
        print(digits*' ' + '+' + 2*len(self._grid)*'-' + '+')
        for i in reversed(list(rows.keys())):
            print(row_fmt.format(self.opts['size']['height'] - i - 1) + '|' + rows[i] + '|')
        print(digits*' ' + '+' + 2*len(self._grid)*'-' + '+')


class GameState(enum.Enum):
    running = 0
    paused = 1
    over = 2


class PySirtet(tk.Frame):
    '''
    Main game window
    '''
    def __init__(self, opts, master=None):
        '''
        Setup game window
        '''
        # Setup options
        self.opts = opts
        self.scale = self.opts['scale']
        self.board_width = self.scale*self.opts['size']['width']
        self.board_height = self.scale*self.opts['size']['height']
        self.border = self.scale//16

        # Setup game state
        self.state_name = tk.StringVar()
        self._set_state(GameState.running)
        self.level = tk.IntVar(value=1)
        self.grid = Grid(self.opts)
        self.piece = None
        self.removed = {l + 1: 0 for l in range(4)}
        self.points = {l + 1: self.grid.width*(l + 1)**2 for l in range(4)}
        self.score = tk.IntVar()

        # Setup TK
        super().__init__(master)
        self.master = master
        self.pack()
        self.create_widgets()
        self.setup_events()
        self.add_piece()
        self.iterate_id = self.master.after(self._get_loop_wait(), self.iterate)

    def _get_loop_wait(self, stick=False):
        '''
        Wait between game ticks [milliseconds]
        '''
        epsilon = sys.float_info.epsilon*3
        level_speed = self.opts['speed']*(math.log(self.level.get(), 2) + 1)
        multiplier = 1e3*(self.opts['stick_fraction'] if stick else 1)
        return round(multiplier/(level_speed if level_speed > epsilon else epsilon) or epsilon)

    def _set_state(self, state):
        '''
        Set the game state
        '''
        self.state = state
        self.state_name.set({
            GameState.running: '',
            GameState.paused: 'Paused',
            GameState.over: 'Game Over',
        }.get(state))

    def _update_score(self, rows_removed):
        '''
        Update the score
        '''
        self.removed[rows_removed] += 1
        self.score.set(self.score.get() + self.points[rows_removed])

    def _update_level(self):
        '''
        Update the game level
        '''
        if not self.opts['constant'] and sum([n*r for n, r in self.removed.items()]) > round(self.opts['level_multiplier']*(math.log(self.level.get(), 2) + 1)):
            self.level.set(self.level.get() + 1)

    def _update_board(self, piece, clear=False):
        '''
        Place or clear piece on the board
        '''
        for v in piece.coords:
            square = self.grid[v]
            colors = piece.colors[v[0]] if piece.name == 'row' and not piece.full else piece.colors
            if clear:
                square.update({'type': None,
                               'id': self.board.delete(square['id']),
                               'colors': {}})
            else:
                square.update({'type': piece.name,
                               'id': self._draw_square(v, colors),
                               'colors': colors})

    def _transform_coord(self, v):
        '''
        pysirtet treats the game board as the first quadrant of the Cartesian
        plane with the origin at the lower left corner, whereas Tkinter,
        conventionally, places the origin in the upper left corner, with
        positive x and y directions pointing right and down, respectively
        '''
        return [v[0], self.opts['size']['height'] - 1 - v[1]]

    def _draw_square(self, v, colors):
        '''
        Draw or clear a polyomino square on the board at v
        '''
        u = self._transform_coord(v)
        return self.board.create_rectangle(self.scale*u[0] + self.border,
                                           self.scale*u[1] + self.border,
                                           self.scale*(u[0] + 1),
                                           self.scale*(u[1] + 1),
                                           fill=colors['normal'],
                                           outline=colors['dark'],
                                           width=self.border)

    def _draw_board(self):
        '''
        Draw the game board
        '''
        board = tk.Canvas(self, width=self.board_width, height=self.board_height)
        board.create_rectangle(0, 0,
                               self.board_width, self.board_height,
                               fill='black',
                               outline='black',
                               width=self.border)

        if self.opts['debug']:
            for v, square in self.grid:
                u = self._transform_coord(v)
                board.create_text((self.scale*u[0], self.scale*u[1]),
                                  text='{},{}'.format(*v),
                                  fill='white', font=('Monospace', 5), anchor=tk.NW)

        return board

    def create_widgets(self):
        '''
        Pack in game widgets
        '''
        self.board = self._draw_board()
        self.board.pack(side='left')

        self.marquee = tk.Frame(self)
        self.marquee.pack(side='right', padx=self.scale, pady=self.scale)

        self.level_board = tk.LabelFrame(self.marquee, text='level')
        self.level_board.pack(side='top')
        self.level_total = tk.Label(self.level_board, textvariable=self.level, width=4)
        self.level_total.pack(side='top')

        self.score_board = tk.LabelFrame(self.marquee, text='score')
        self.score_board.pack(side='top')
        self.score_total = tk.Label(self.score_board, textvariable=self.score, width=4)
        self.score_total.pack(side='top')

        self.state_label = tk.Label(self.marquee, textvariable=self.state_name)
        self.state_label.pack(side='top')

    def setup_events(self):
        '''
        Respond to inputs and other game conditions: mainly key input
        '''
        for name, key in self.opts['keys'].items():
            self.master.bind(key, getattr(self, name))

    def pause(self, event):
        '''
        (Un)pause the game
        '''
        if self.state == GameState.running:
            self.after_cancel(self.iterate_id)
            self._set_state(GameState.paused)
        elif self.state == GameState.paused:
            self.iterate_id = self.master.after(self._get_loop_wait(), self.iterate)
            self._set_state(GameState.running)

    def move(transformation):
        '''
        Map keys to transformations on the current piece
        '''
        def transform(self, event):
            '''
            Transform the current piece
            '''
            if self.state == GameState.running:
                self.move_piece(transformation)
        return transform

    left = move(Transformation.left)
    right = move(Transformation.right)
    left_side = move(Transformation.min)
    right_side = move(Transformation.max)
    rotate_left = move(Transformation.ccw)
    rotate_right = move(Transformation.cw)
    down = move(Transformation.down)
    drop = move(Transformation.bottom)

    def iterate(self):
        '''
        Move the active piece one row down
        '''
        if not self.move_piece(Transformation.down):
            self.remove_rows()
            self.add_piece()
        if self.opts['debug']:
            self.grid.print()
        if self.state != GameState.over:
            self.iterate_id = self.master.after(self._get_loop_wait(), self.iterate)

    def add_piece(self):
        '''
        Add a tetromino to the top center of the board
        '''
        name = random.choice(tetrominoes).name
        self.piece = copy.deepcopy([t for t in tetrominoes if t.name == name][0])
        if self.piece.translate([self.opts['size']['width']//2, self.opts['size']['height'] - 1 - self.piece.max(1)], self.grid):
            self._update_board(self.piece)
        else:
            self._set_state(GameState.over)

    def move_piece(self, movement):
        '''
        Move current piece according to the movement requested:

        - (cw) Rotate π/2 clockwise about piece proper origin
        - (ccw) Rotate π/2 counterclockwise about piece proper origin
        - (left) One column left
        - (right) One column right
        - (down) One row down
        - (min) To the leftmost available position
        - (max) To the rightmost available position
        - (bottom) To the lowest available position
        '''
        # Map each movement to a predefined transformation on the current piece
        transform, kwargs = {
            Transformation.cw: (self.piece.rotate, {}),
            Transformation.ccw: (self.piece.rotate, {}),
            Transformation.left: (self.piece.translate, {}),
            Transformation.right: (self.piece.translate, {}),
            Transformation.down: (self.piece.translate, {}),
            Transformation.min: (self.piece.translate, {'incremental': True}),
            Transformation.max: (self.piece.translate, {'incremental': True}),
            Transformation.bottom: (self.piece.translate, {'incremental': True}),
        }.get(movement)
        # Execute the transformation on the current piece if possible
        self._update_board(self.piece, clear=True)
        result = transform(movement, self.grid, **kwargs)
        self._update_board(self.piece)  # (Re)place
        return result

    def remove_rows(self):
        '''
        Remove any full rows
        '''
        # Gather all full and partial rows and mark full rows
        rows = []
        full_count = 0
        full_colors={'normal': '#FFFFFF',
                     'light' : '#FFFFFF',
                     'dark'  : '#FFFFFF'}
        for y in range(self.grid.height):
            row_coords = [[x, y] for x in range(self.grid.width) if self.grid[x, y]['type']]
            if len(row_coords):
                row = Polyomino('row', {v[0]: self.grid[v]['colors'] for v in row_coords}, row_coords)
                rows.append(row)
                row.full = False
                row.full_below = full_count
            if len(row_coords) == self.grid.width:
                full_count += 1
                row.full = True
                row.colors = full_colors
                self._update_board(row, clear=True)
                self._update_board(row)

        def remove():
            '''
            Remove the rows
            '''
            # Remove full rows and move partial rows down into the vacancies
            if full_count:
                for row in rows:
                    if row.full:
                        self._update_board(row, clear=True)
                    elif row.full_below:
                        self._update_board(row, clear=True)
                        row.translate([0, -row.full_below], self.grid)
                        self._update_board(row)
                self._update_score(full_count)
                self._update_level()
        self.master.after(self._get_loop_wait(stick=True), remove)


class Config:
    '''
    Provide and save game configuration
    '''
    def __init__(self, test=False):
        '''
        Setup game configuration.  When ``test == True``, command line
        arguments are not processed
        '''
        self.test = test

        self.defaults = {
            'config_file': os.path.join(os.environ.get('HOME', ''), '.config/pysirtet/pysirtet.conf'),
            'debug': False,
            'board': {
                'size': {'width': 10, 'height': 22},  # [blocks]
                'scale': 32,  # [pixels/block] number of pixels per block side
            },
            'speed': 1,  # [blocks/second] Initial speed: increases by log_2 of the previous level
            'level_multiplier': 16,  # [rows/level] Initial number of rows cleared for level advancement: increases by log_2 of the previous level
            'constant': False,  # Do not increase game speed
            'stick_fraction': 1/4,  # Fraction of the game speed to wait when a piece bottoms out and a new piece is introduced
            'keys': {
                'pause': 'p',
                'left': ',',
                'right': '.',
                'left_side': 'z',
                'right_side': '/',
                'rotate_left': 'm',
                'rotate_right': 'v',
                'down': 'x',
                'drop': 'c',
            }
        }

    def _config_file(self, arg):
        '''
        Create the file if it does not exist and return the path
        '''
        if not os.path.exists(arg):
            path, file_name = os.path.split(arg)
            if not os.path.exists(path):
                os.makedirs(path)

        return arg

    def _size(self, arg):
        '''
        Validate size argument
        '''
        # Match data
        size_pattern = (r'(?P<width>\d+)'    # width pixels
                        r'(?P<mlt>[xX])'     # times
                        r'(?P<height>\d+)')  # height pixels
        match = re.match(size_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Construct return data and return
        board_size = {}
        for token in ('width', 'height'):
            value = match.group(token)
            board_size[token] = int(value) if value is not None else 0
        return board_size

    def _get_config(self, config_file):
        '''
        Read configs from config file
        '''
        opts = {}
        config = configparser.SafeConfigParser()
        config.read(config_file)

        # Window configs
        opts['board'] = {}
        if config.has_section('board'):
            opts['board']['size'] = config.get('board', 'size', vars=self.defaults)
            opts['board']['scale'] = config.get('board', 'scale', vars=self.defaults)
        else:
            opts['board']['size'] = self.defaults['board']['size']
            opts['board']['scale'] = self.defaults['board']['scale']

        # Game configs
        if config.has_section('game'):
            opts['debug'] = config.get('game', 'debug', vars=self.defaults)
            opts['speed'] = config.get('game', 'speed', vars=self.defaults)
            opts['level_multiplier'] = config.get('game', 'level_multiplier', vars=self.defaults)
            opts['constant'] = config.get('game', 'constant', vars=self.defaults)
            opts['stick_fraction'] = config.get('game', 'stick_fraction', vars=self.defaults)
        else:
            opts['debug'] = self.defaults['debug']
            opts['speed'] = self.defaults['speed']
            opts['level_multiplier'] = self.defaults['level_multiplier']
            opts['constant'] = self.defaults['constant']
            opts['stick_fraction'] = self.defaults['stick_fraction']

        # Keys configs
        opts['keys'] = {}
        if config.has_section('keys'):
            for key in opts['keys'].keys():
                opts['keys'][key] = config.get('keys', key, vars=self.defaults['keys'])
        else:
            opts['keys'] = self.defaults['keys']

        return opts

    def _get_args(self):
        '''
        Read configs from command line
        '''
        desc='Polyomino tessellation game written in Tkinter'
        arg_parser = ArgumentParser(description=desc,
                                    formatter_class=ArgumentDefaultsHelpFormatter)
        arg_parser.add_argument('-c', '--config-file',
                                default=self.defaults['config_file'],
                                type=self._config_file,
                                help='Specify location of the config file')
        arg_parser.add_argument('-d', '--debug',
                                default=self.defaults['debug'],
                                action='store_true',
                                help='Run game in debug mode')
        arg_parser.add_argument('-s', '--size',
                                default='{0[width]}x{0[height]}'.format(self.defaults['board']['size']),
                                type=self._size,
                                help='Board size [blocks^2]')
        arg_parser.add_argument('-a', '--scale',
                                default=self.defaults['board']['scale'],
                                type=int,
                                help='Board scale [pixels/block]')
        arg_parser.add_argument('-S', '--speed',
                                default=self.defaults['speed'],
                                type=float,
                                help='Initial speed [blocks/second]')
        arg_parser.add_argument('-o', '--constant',
                                default=self.defaults['constant'],
                                action='store_true',
                                help='Do not increase game speed')
        return vars(arg_parser.parse_args())

    def get_opts(self):
        '''
        Setup program options
        '''
        # Config resolution:
        # 0. programmatic defaults
        # 1. dynamically set programmatic values
        # 2. config file values
        # 3. command line values
        args = self.defaults if self.test else self._get_args()
        opts = self._get_config(args['config_file'])
        opts.update(args)
        return opts

    def write_opts(self, opts):
        '''
        Save game configs to file when config dialog is closed
        '''
        # TODO


def pysirtet():
    '''
    Execute the game
    '''
    try:
        PySirtet(Config().get_opts(), master=tk.Tk(className='pysirtet')).mainloop()
    except KeyboardInterrupt:
        exit(0)


if __name__ == '__main__' : pysirtet()
