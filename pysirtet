#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Import python libs
import os
import re
import sys
import copy
import enum
import random
import configparser
from argparse import ArgumentParser, ArgumentTypeError, ArgumentDefaultsHelpFormatter
import tkinter as tk


class AngularDirection(enum.Enum):
    cw = -1  # Clockwise
    ccw = +1  # Counterclockwise


class Extrema(enum.Enum):
    min = -1
    max = +1


class Polyomino(object):
    def __init__(self, name, colors, coords, origin=[0, 0], ordinal=4):
        self.name = name
        self.colors = colors

        self.coords = coords  # Coordinates for each square in the polyomino
        self.o = origin  # Origin of the polyomino's proper reference frame relative to constraint frame
        self.ordinal = ordinal  # Polyomino ordinal (4 == tetromino, etc.)

    def _check_constraints(self, r, constraints):
        '''
        Validate whether the coordinates r = (x_i, y_i) are within the constraints
        '''
        # Check that r points to the interior of the grid
        try:
            constraints[r]
        except IndexError:
            return False
        # Only the empty grid squares are allowed
        if constraints[r] != None:
            return False

        return True

    def rotate(self, direction, constraints):
        '''
        Rotate polyomino clockwise or counterclockwise (±π/2) about its
        proper origin if the resulting transformation is contained within the
        constraints
        '''
        # Prepare new coordinates and rotation tensor
        coords = self.ordinal*[[]]
        sgn = direction.value  # +1 for ccw and -1 for cw

        # Apply rotation tensor if allowed
        for i, c in enumerate(self.x):
            coords[i][0] = -sgn*(self.coords[i][1] - self.o[1]) + self.o[0]
            coords[i][1] = sgn*(self.coords[i][0] - self.o[0]) + self.o[1]
            if not self._check_constraints(coords[i], constraints):
                return False

        # Set new coordinates
        self.coords = coords
        return True

    def translate(self, v, constraints):
        '''
        Translate polyomino by the vector v if the resulting transformation is
        contained within the constraints
        '''
        # Redefine v as explicit coordinates in the constraint reference frame
        if v[0] == Extrema.min:
            v = [-min(self.coords[0]), 0]
        elif v[0] == Extrema.max:
            v = [len(constraints) - max(self.coords[0]), 0]

        # Prepare new coordinates and new proper origin in the constraint frame
        coords = self.ordinal*[[0, 0]]
        o = [self.o[0] + v[0], self.o[1] + v[1]]

        # Apply translation vector v if allowed
        print(self._check_constraints([9,21], constraints))
        for i, c in enumerate(self.coords):
            coords[i][0] = self.coords[i][0] + v[0]
            coords[i][1] = self.coords[i][1] + v[1]
            if not self._check_constraints(coords[i], constraints):
                print('checking {}'.format(coords[i]))
                print(False)
                return False

        # Set new coordinates and proper origin at translated position
        self.coords = coords
        self.o = o
        return True


class Tetrominoes(enum.Enum):
    Z = 1
    S = 2
    l = 3
    T = 4
    o = 5
    L = 6
    J = 7


tetromino_data = (
    Polyomino(
        name=Tetrominoes.Z,
        coords=[[-1, 1], [0, 1], [0, 0], [1, 0]],
        colors={'normal': '#CC6666',
                'light' : '#F89FAB',
                'dark'  : '#803C3B'}
    ),
    Polyomino(
        name=Tetrominoes.S,
        coords=[[-1, 0], [0, 0], [0, 1], [1, 1]],
        colors={'normal': '#66CC66',
                'light' : '#79FC79',
                'dark'  : '#3B803B'}
    ),
    Polyomino(
        name=Tetrominoes.l,
        coords=[[-1, 0], [0, 0], [1, 0], [2, 0]],
        colors={'normal': '#6666CC',
                'light' : '#7979FC',
                'dark'  : '#3B3B80'}
    ),
    Polyomino(
        name=Tetrominoes.T,
        coords=[[-1, 1], [0, 1], [0, 0], [1, 1]],
        colors={'normal': '#CCCC66',
                'light' : '#FCFC79',
                'dark'  : '#80803B'}
    ),
    Polyomino(
        name=Tetrominoes.o,
        coords=[[0, 1], [0, 0], [1, 0], [1, 1]],
        colors={'normal': '#CC66CC',
                'light' : '#FC79FC',
                'dark'  : '#803B80'}
    ),
    Polyomino(
        name=Tetrominoes.L,
        coords=[[1, 2], [1, 1], [1, 0], [1, 0]],
        colors={'normal': '#66CCCC',
                'light' : '#79FCFC',
                'dark'  : '#3B8080'}
    ),
    Polyomino(
        name=Tetrominoes.J,
        coords=[[1, 2], [1, 1], [1, 0], [0, 0]],
        colors={'normal': '#DAAA00',
                'light' : '#FCC600',
                'dark'  : '#806200'}
    ),
)


class Grid(object):
    '''
    The rectangular region of squares that comprises the game state.  The
    squares map to the integer coordinates in the first quadrant of the
    cartesian plane such that each square is represented by the (integral)
    point at its upper right corner.  The origin corresponds to the upper right
    corner of the grid
    '''
    def __init__(self, opts):
        '''
        Setup game grid
        '''
        # Store program options
        self.opts = opts

        # Initialize internal grid
        self._grid = [[None for i in range(self.opts['size']['width'])] for j in range(self.opts['size']['height'])]

    def __getitem__(self, v):
        '''
        Retrieve the square at coordinates v from the origin
        '''
        return self._grid[v[0]][v[1]]

    def __setitem__(self, v, t):
        '''
        Update the square at coordinates v from the origin to be of tetromino type t
        '''
        self._grid[v[0]][v[1]] = t

    def update(self, tetromino_type, coords):
        '''
        Set the tetromino type at coords
        '''
        for square in coords:
            self[square] = tetromino_type

    def print(self):
        '''
        Display grid state
        '''
        for column in self._grid:
            print('|' + ''.join(' ' if e is None else e.name for e in column) + '|')


class PySirtet(tk.Frame):
    '''
    Main game window
    '''
    def __init__(self, opts, master=None):
        '''
        Setup game window
        '''
        # Store program options
        self.opts = opts

        # Setup grid
        self.grid = Grid(self.opts)
        self.add_tetromino()

        # Setup TK
        self.master = master
        super().__init__(master)
        self.pack()
        self.create_widgets()
        self.master.after(self._get_loop_wait(), self.iterate)

    def _get_loop_wait(self):
        '''
        Wait between game ticks [milliseconds]
        '''
        epsilon = sys.float_info.epsilon*4
        return round(1e3/(self.opts['speed'] if self.opts['speed'] > epsilon else epsilon))

    def iterate(self):
        '''
        Main loop of the game window
        '''
        print('game loop')
        self.master.after(self._get_loop_wait(), self.iterate)

    def create_widgets(self):
        '''
        Pack in game widgets
        '''
        self.board = tk.Canvas(self,
                               width=self.opts['geometry']['width'],
                               height=self.opts['geometry']['height'])
        self.board.create_rectangle(0, 0,
                                    self.opts['geometry']['width'], self.opts['geometry']['height'],
                                    fill='black', width=0)
        self.board.pack(side="top")

    def add_tetromino(self):
        '''
        Add a tetromino to the top center of the board
        '''
        # Get new piece
        new_name = random.choice(tuple(Tetrominoes))
        self.piece = copy.deepcopy([td for td in tetromino_data if td.name == new_name][0])
        # Translate piece to top center of board
        print(self.piece.coords)
        self.piece.translate([self.opts['size']['width']//2, self.opts['size']['height'] - 1 - max([c[1] for c in self.piece.coords])], self.grid)
        print(self.piece.coords)
        self.grid.update(self.piece.name, self.piece.coords)
        self.grid.print()
        exit()


class Game(object):
    pass


def get_opts():
    '''
    Setup program options
    '''
    defaults = {
        'config_file': os.path.join(os.environ.get('HOME', ''), '.config/pysirtet/pysirtet.conf'),
        'size': {'width': 10, 'height': 22},  # [blocks]
        'geometry_scale': 16,  # [pixels^2/blocks] Used to scale geometry size to the board size
        'geometry': '',  # The default geometry is set after the size is known
        'speed': 1,  # [blocks/second]
        'keys': {
            'pause': 'p',
            'left': ',',
            'right': '.',
            'left_wall': 'z',
            'right_wall': '/',
            'rotate_left': 'x',
            'rotate_right': 'c',
            'down': 'm',
            'drop': 'v',
        }
    }
    def default_geometry(size):
        '''
        Calculate the default geometry from the size
        '''
        return {'height': defaults['geometry_scale']*size['height'],
                'width': defaults['geometry_scale']*size['width']}

    def config_file(arg):
        '''
        Create the file if it does not exist and return the path
        '''
        if not os.path.exists(arg):
            path, file_name = os.path.split(arg)
            if not os.path.exists(path):
                os.makedirs(path)

        return arg

    def size(arg):
        '''
        Validate size argument
        '''
        # Match data
        size_pattern = (r'(?P<width>\d+)'    # width pixels
                        r'(?P<mlt>[xX])'     # times
                        r'(?P<height>\d+)')  # height pixels
        match = re.match(size_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Construct return data and return
        geometry = {}
        for token in ('width', 'height'):
            value = match.group(token)
            geometry[token] = int(value) if value is not None else 0
        return geometry

    def geometry(arg):
        '''
        Validate geometry argument
        '''
        # Match data
        geom_pattern = (r'(?P<width>\d+)'       # width pixels
                        r'(?P<mlt>[xX])'        # times
                        r'(?P<height>\d+)'      # height pixels
                        r'(?:'                  # optional non-capturing group for position
                            r'(?P<xsgn>[+-])*'  # x sign
                            r'(?P<xpos>\d+)*'   # x position
                            r'(?P<ysgn>[+-])*'  # y sign
                            r'(?P<ypos>\d+)*'   # y position
                        r')*')                  # close optional group
        match = re.match(geom_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Validate position
        extra = ('xsgn', 'xpos', 'ysgn', 'ypos')
        found_extra = [match.group(token) for token in extra]
        if any(found_extra) and not all(found_extra):
            raise ArgumentTypeError('Incorrect position')

        # Construct return data and return
        geometry = {}
        for token in ('width', 'height', 'xpos', 'ypos'):
            value = match.group(token)
            geometry[token] = int(value) if value is not None else 0
        for token in ('xsgn', 'ysgn'):
            value = match.group(token)
            geometry[token] = value if value is not None else '+'
        return geometry

    def get_config(config_file):
        '''
        Read configs from config file
        '''
        opts = {}
        config = configparser.SafeConfigParser()
        config.read(config_file)

        # Window configs
        if config.has_section('window'):
            opts['size'] = config.get('window', 'size', vars=defaults)
            opts['geometry'] = config.get('window', 'geometry', vars={'geometry': default_geometry(opts['size'])})
        else:
            opts['size'] = defaults['size']
            opts['geometry'] = default_geometry(defaults['size'])

        # Game configs
        if config.has_section('game'):
            opts['speed'] = config.get('game', 'speed', vars=defaults)
        else:
            opts['speed'] = defaults['speed']

        # Keys configs
        if config.has_section('keys'):
            opts['keys'] = {}
            for key in opts['keys'].keys():
                opts['keys'][key] = config.get('keys', key, vars=defaults['keys'])
        else:
            opts['keys'] = defaults['keys']

        return opts

    def get_args():
        '''
        Read configs from command line
        '''
        desc='Polyomino tessellation game written in tkinter'
        arg_parser = ArgumentParser(description=desc,
                                    formatter_class=ArgumentDefaultsHelpFormatter)
        arg_parser.add_argument('-c', '--config-file',
                                default=defaults['config_file'],
                                type=config_file,
                                help='Specify location of the config file')
        arg_parser.add_argument('-s', '--size',
                                default='{0[width]}x{0[height]}'.format(defaults['size']),
                                type=size,
                                help='Board size')
        arg_parser.add_argument('-g', '--geometry',
                                default='{0[width]}x{0[height]}'.format(default_geometry(defaults['size'])),
                                dest='geometry',
                                type=geometry,
                                help='Specify window geometry; see X(7) for info on'
                                     ' how to specify geometries')
        arg_parser.add_argument('-S', '--speed',
                                default=defaults['speed'],
                                type=float,
                                help='Game speed [blocks/second]; if set, the game will run'
                                     ' constantly at this speed regardless of the'
                                     ' number of removed rows')
        return vars(arg_parser.parse_args())

    # Load configs from command line
    args = get_args()

    # Load configs from config file
    opts = get_config(args['config_file'])

    # Default window size to a scale factor of the board size
    if args['size'] != defaults['size']:
        if (args['geometry']['width'] == default_geometry(defaults['size'])['width']
        and args['geometry']['height'] == default_geometry(defaults['size'])['height']):
            args['geometry'].update(default_geometry(args['size']))

    # Override configs with values from command line
    opts.update(args)

    return opts


def write_config(opts):
    '''
    Save game configs to file when config dialog is closed
    '''
    # TODO


def pysirtet():
    '''
    Execute the game
    '''
    try:
        PySirtet(get_opts(), master=tk.Tk()).mainloop()
    except KeyboardInterrupt:
        exit(0)


if __name__ == '__main__' : pysirtet()
