#!/usr/bin/env python2

import os
import re
import copy
import random
import ConfigParser
from argparse import ArgumentParser, ArgumentTypeError, ArgumentDefaultsHelpFormatter

import wx

class Polyomino(object):
    def __init__(self, name, coords, colors):
        self.name = name
        self.coords = coords
        self.colors = colors

    def x(self, index):
        return self.coords[index][0]

    def y(self, index):
        return self.coords[index][1]

    def set_x(self, index, x):
        self.coords[index][0] = x

    def set_y(self, index, y):
        self.coords[index][1] = y

    def min_x(self):
        return min([self.coords[i][0] for i in range(4)])

    def max_x(self):
        return max([self.coords[i][0] for i in range(4)])

    def min_y(self):
        return min([self.coords[i][1] for i in range(4)])

    def max_y(self):
        return max([self.coords[i][1] for i in range(4)])

    def rotated_left(self):
        result = Polyomino(self.name, copy.deepcopy(self.coords), self.colors)

        for i in range(4):
            result.set_x(i, self.y(i))
            result.set_y(i, -self.x(i))

        return result

    def rotated_right(self):
        result = Polyomino(self.name, copy.deepcopy(self.coords), self.colors)

        for i in range(4):
            result.set_x(i, -self.y(i))
            result.set_y(i, self.x(i))

        return result


tetrominoes = [
    Polyomino(
        name='Z',
        coords=[[0, -1], [0, 0], [-1, 0], [-1, 1]],
        colors={'normal': '#CC6666',
                'light' : '#F89FAB',
                'dark'  : '#803C3B'}
    ),
    Polyomino(
        name='S',
        coords=[[0, -1], [0, 0], [1, 0], [1, 1]],
        colors={'normal': '#66CC66',
                'light' : '#79FC79',
                'dark'  : '#3B803B'}
    ),
    Polyomino(
        name='l',
        coords=[[0, -1], [0, 0], [0, 1], [0, 2]],
        colors={'normal': '#6666CC',
                'light' : '#7979FC',
                'dark'  : '#3B3B80'}
    ),
    Polyomino(
        name='T',
        coords=[[-1, 0], [0, 0], [1, 0], [0, 1]],
        colors={'normal': '#CCCC66',
                'light' : '#FCFC79',
                'dark'  : '#80803B'}
    ),
    Polyomino(
        name='o',
        coords=[[0, 0], [1, 0], [0, 1], [1, 1]],
        colors={'normal': '#CC66CC',
                'light' : '#FC79FC',
                'dark'  : '#803B80'}
    ),
    Polyomino(
        name='L',
        coords=[[-1, -1], [0, -1], [0, 0], [0, 1]],
        colors={'normal': '#66CCCC',
                'light' : '#79FCFC',
                'dark'  : '#3B8080'}
    ),
    Polyomino(
        name='J',
        coords=[[1, -1], [0, -1], [0, 0], [0, 1]],
        colors={'normal': '#DAAA00',
                'light' : '#FCC600',
                'dark'  : '#806200'}
    ),
]


class PySirtet(wx.Frame):
    '''
    Main game window
    '''
    def __init__(self, opts):
        '''
        Setup game window
        '''
        # Create frame
        wx.Frame.__init__(self,
                          parent=None,
                          title='PySirtet',
                          size=(opts['geometry']['width'], opts['geometry']['height']))

        # Store program options
        self.opts = opts

        # Setup additional features and attributes of the game window
        self.status_bar = self.CreateStatusBar()

        # Setup game panel
        self.game = Game(self, opts)

        # Display window
        self.Centre()
        self.Show(True)


class Game(wx.Panel):
    '''
    Wrapper panel around the board panel so that the board's aspect ratio is
    preserved on window resize.
    '''
    def __init__(self, parent, opts):
        wx.Panel.__init__(self, parent)

        # Store program options
        self.opts = opts

        # Setup board
        self.board = Board(self, opts)
        self.board.SetFocus()
        self.board.start()

        # Setup size
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.board, 1, flag=wx.ALIGN_CENTER_HORIZONTAL|wx.SHAPED)
        self.SetSizer(sizer)


class Board(wx.Panel):
    '''
    Game board
    '''
    ID_TIMER = 1

    def __init__(self, parent, opts):
        '''
        Setup board
        '''
        # Create panel
        wx.Panel.__init__(self,
                          parent,
                          size=(opts['size']['width'], opts['size']['height']))

        # Store program options
        self.opts = opts

        # Setup additional features and attributes of the game board
        self.width = opts['size']['width']
        self.height = opts['size']['height']
        self.speed = opts['speed'] or 700
        self.SetBackgroundColour(wx.BLACK)

        self.timer = wx.Timer(self, Board.ID_TIMER)
        self.cur_piece = self.random_piece()
        self.new_piece = self.random_piece()
        self.cur_x = 0
        self.cur_y = 0

        self.score = 0
        self.rows_removed = 0
        self.clear_board()
        self.update_status()

        # Setup states
        self.is_started = False
        self.is_paused = False

        # Setup bindings
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_TIMER, self.OnTimer, id=Board.ID_TIMER)

    def random_piece(self):
        '''
        Randomly choose a polyomino
        '''
        return random.choice(tetrominoes)

    def get_piece(self, name):
        '''
        Return the piece corresponding to the given name
        '''
        for tetromino in tetrominoes:
            if tetromino.name == name:
                return tetromino

    def clear_board(self):
        '''
        Setup and clear the board
        '''
        self.grid = [['' for i in range(self.height)] for j in range(self.width)]

    def update_status(self, state=''):
        '''
        Set status bar state
        '''
        # Get status bar
        status_bar = self.GetParent().GetParent().status_bar

        # Status text
        status = ['Score: {}'.format(self.score),
                  'Rows Removed: {}'.format(self.rows_removed)]
        if state == 'paused':
            status.append('(Paused)')
        elif state == 'over':
            status.append('(Game Over)')

        # Set status
        status_bar.SetStatusText(' | '.join(status))

    def square_size(self):
        '''
        Return the size of a grid square
        '''
        width = self.GetClientSize().GetWidth()/self.width
        height = self.GetClientSize().GetHeight()/self.height

        return (width, height)

    def start(self):
        '''
        Start game
        '''
        if self.is_paused:
            return

        self.is_started = True
        self.score = 0
        self.rows_removed = 0
        self.clear_board()
        self.update_status()

        self.next_piece()
        self.timer.Start(self.speed)

    def pause(self):
        '''
        Pause game
        '''
        if not self.is_started:
            return

        self.is_paused = not self.is_paused

        if self.is_paused:
            self.timer.Stop()
            self.update_status('paused')
        else:
            self.timer.Start(self.speed)
            self.update_status()

        self.Refresh()

    def OnPaint(self, event):
        '''
        Paint event
        '''
        dc = wx.PaintDC(self)

        size = self.GetClientSize()
        square_width, square_height = self.square_size()
        board_top = size.GetHeight() - self.height*square_height

        for i in range(self.height):
            for j in range(self.width):
                piece_name = self.grid[j][self.height - i - 1]
                if piece_name != '':
                    self.draw_square(dc,
                        j*square_width,
                        board_top + i*square_height, self.get_piece(piece_name))

        if self.cur_piece.name != '':
            for i in range(4):
                x = self.cur_x + self.cur_piece.x(i)
                y = self.cur_y - self.cur_piece.y(i)
                self.draw_square(dc, x*square_width,
                    board_top + (self.height - y - 1)*square_height,
                    self.cur_piece)

    def OnKeyDown(self, event):
        '''
        Key input event
        '''
        # Skip if not started or no piece
        if not self.is_started or self.cur_piece.name == '':
            event.Skip()
            return

        keycode = event.GetKeyCode()

        # Pause
        if keycode == ord(self.opts['keys']['pause'].upper()):
            self.pause()
            return
        if self.is_paused:
            return

        # Left
        elif keycode == ord(self.opts['keys']['left_wall'].upper()):
            self.try_move(self.cur_piece, self.cur_x - 1, self.cur_y)
        elif keycode == ord(self.opts['keys']['left'].upper()):
            self.try_move(self.cur_piece, self.cur_x - 1, self.cur_y)

        # Right
        elif keycode == ord(self.opts['keys']['right'].upper()):
            self.try_move(self.cur_piece, self.cur_x + 1, self.cur_y)
        elif keycode == ord(self.opts['keys']['right_wall'].upper()):
            self.try_move(self.cur_piece, self.cur_x + 1, self.cur_y)

        # Rotate
        elif keycode == ord(self.opts['keys']['rotate_left'].upper()):
            self.try_move(self.cur_piece.rotated_left(), self.cur_x, self.cur_y)
        elif keycode == ord(self.opts['keys']['rotate_right'].upper()):
            self.try_move(self.cur_piece.rotated_right(), self.cur_x, self.cur_y)

        # Down
        elif keycode == ord(self.opts['keys']['down'].upper()):
            self.one_row_down()
        elif keycode == ord(self.opts['keys']['drop'].upper()):
            self.drop_down()
        else:
            event.Skip()

    def OnTimer(self, event):
        '''
        Timer step event
        '''
        if event.GetId() == Board.ID_TIMER:
            self.one_row_down()
        else:
            event.Skip()

    def drop_down(self):
        '''
        Move current piece as far down as possible and introduce next piece
        '''
        new_y = self.cur_y

        while new_y > 0:
            if not self.try_move(self.cur_piece, self.cur_x, new_y - 1):
                break
            new_y -= 1

        self.piece_dropped()

    def one_row_down(self):
        '''
        Move current piece down one row
        '''
        if not self.try_move(self.cur_piece, self.cur_x, self.cur_y - 1):
            self.piece_dropped()

    def piece_dropped(self):
        '''
        Introduce new piece at the top of the board
        '''
        for i in range(4):
            x = self.cur_x + self.cur_piece.x(i)
            y = self.cur_y - self.cur_piece.y(i)
            self.grid[x][y] = self.cur_piece.name

        self.remove_full_rows()

        self.next_piece()

    def remove_full_rows(self):
        '''
        Remove a full row from the board
        '''
        # Collect full rows
        full_rows = []
        for i in range(self.height):
            n = sum([1 for j in range(self.width) if self.grid[j][i] != ''])
            if n == self.width:
                full_rows.append(i)
        full_rows.reverse()

        # Remove full rows and move all above rows down
        for m in full_rows:
            for l in range(self.width):
                # All rows but top
                for k in range(m, self.height - 1):
                    self.grid[l][k] = self.grid[l][k + 1]
                # Top row
                self.grid[l][self.height - 1] = ''

        # Update game state
        if len(full_rows):
            self.update_score(len(full_rows))
            self.update_status()
            self.Refresh()

    def update_score(self, num_full_rows):
        '''
        Update game score.  The score increases by a triangular sum of the
        number of rows removed to incentivize removing more at once.
        '''
        self.score += sum([i for i in range(1, num_full_rows + 1)])  # TODO: factor in game level
        self.rows_removed += num_full_rows

    def next_piece(self):
        '''
        Setup next piece
        '''
        # Cycle pieces
        self.cur_piece = self.new_piece
        self.new_piece = self.random_piece()

        # Update grid cursor
        self.cur_x = self.width/2 + 1
        self.cur_y = self.height - 1 + self.cur_piece.min_y()

        # Test halting condition
        if not self.try_move(self.cur_piece, self.cur_x, self.cur_y):
            self.timer.Stop()
            self.is_started = False
            self.update_status('over')

    def try_move(self, new_piece, new_x, new_y):
        '''
        Attempt to transform (translate, rotate) current piece
        '''
        for i in range(4):

            x = new_x + new_piece.x(i)
            y = new_y - new_piece.y(i)

            if x < 0 or x >= self.width or y < 0 or y >= self.height:
                return False
            if self.grid[x][y] != '':
                return False

        self.cur_piece = new_piece
        self.cur_x = new_x
        self.cur_y = new_y
        self.Refresh()

        return True

    def draw_square(self, dc, x, y, piece):
        '''
        Draw a square on the board
        '''
        # Get square size
        square_width, square_height = self.square_size()

        # Draw light edges
        pen = wx.Pen(piece.colors['light'])
        pen.SetCap(wx.CAP_PROJECTING)
        dc.SetPen(pen)

        dc.DrawLine(x, y + square_height - 1, x, y)
        dc.DrawLine(x, y, x + square_width - 1, y)

        # Draw dark edges
        darkpen = wx.Pen(piece.colors['dark'])
        darkpen.SetCap(wx.CAP_PROJECTING)
        dc.SetPen(darkpen)

        dc.DrawLine(x + 1, y + square_height - 1,
            x + square_width - 1, y + square_height - 1)
        dc.DrawLine(x + square_width - 1,
            y + square_height - 1, x + square_width - 1, y + 1)

        # Paint square surface
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(wx.Brush(piece.colors['normal']))
        dc.DrawRectangle(x + 1, y + 1, square_width - 2,
            square_height - 2)


def get_opts():
    '''
    Setup program options
    '''
    def config_file(arg):
        '''
        Create the file if it does not exist and return the path
        '''
        if not os.path.exists(arg):
            path, file_name = os.path.split(arg)
            if not os.path.exists(path):
                os.makedirs(path)

        return arg

    def size(arg):
        '''
        Validate size argument
        '''
        # Match data
        size_pattern = (r'(?P<width>\d+)'    # width pixels
                        r'(?P<mlt>[xX])'     # times
                        r'(?P<height>\d+)')  # height pixels
        match = re.match(size_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Construct return data and return
        geometry = {}
        for token in ('width', 'height'):
            value = match.group(token)
            geometry[token] = int(value) if value is not None else 0
        return geometry

    def geometry(arg):
        '''
        Validate geometry argument
        '''
        # Match data
        geom_pattern = (r'(?P<width>\d+)'       # width pixels
                        r'(?P<mlt>[xX])'        # times
                        r'(?P<height>\d+)'      # height pixels
                        r'(?:'                  # optional non-capturing group for position
                            r'(?P<xsgn>[+-])*'  # x sign
                            r'(?P<xpos>\d+)*'   # x position
                            r'(?P<ysgn>[+-])*'  # y sign
                            r'(?P<ypos>\d+)*'   # y position
                        r')*')                  # close optional group
        match = re.match(geom_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Validate position
        extra = ('xsgn', 'xpos', 'ysgn', 'ypos')
        found_extra = [match.group(token) for token in extra]
        if any(found_extra) and not all(found_extra):
            raise ArgumentTypeError('Incorrect position')

        # Construct return data and return
        geometry = {}
        for token in ('width', 'height', 'xpos', 'ypos'):
            value = match.group(token)
            geometry[token] = int(value) if value is not None else 0
        for token in ('xsgn', 'ysgn'):
            value = match.group(token)
            geometry[token] = value if value is not None else '+'
        return geometry

    defaults = {
        'config_file': os.path.join(os.environ.get('HOME', ''), '.config/pysirtet/pysirtet.conf'),
        'size': {'width': 10, 'height': 22},
        'geometry_scale': 32,  # Used to scale geometry size to the board size
        'geometry': '',  # The default geometry is set after the size is known
        'speed': 0,
        'keys': {
            'pause': 'p',
            'left': ',',
            'right': '.',
            'left_wall': 'z',
            'right_wall': '/',
            'rotate_left': 'x',
            'rotate_right': 'c',
            'down': 'm',
            'drop': 'v',
        }
    }
    def default_geometry(size):
        '''
        Calculate the default geometry from the size
        '''
        return {'height': defaults['geometry_scale']*size['height'],
                'width': defaults['geometry_scale']*size['width']}

    def get_config(config_file):
        '''
        Read configs from config file
        '''
        opts = {}
        config = ConfigParser.SafeConfigParser()
        config.read(config_file)

        # Window configs
        if config.has_section('window'):
            opts['size'] = config.get('window', 'size', vars=defaults)
            opts['geometry'] = config.get('window', 'geometry', vars={'geometry': default_geometry(opts['size'])})
        else:
            opts['size'] = defaults['size']
            opts['geometry'] = default_geometry(defaults['size'])

        # Game configs
        if config.has_section('game'):
            opts['speed'] = config.get('game', 'speed', vars=defaults)
        else:
            opts['speed'] = defaults['speed']

        # Keys configs
        if config.has_section('keys'):
            opts['keys'] = {}
            for key in opts['keys'].keys():
                opts['keys'][key] = config.get('keys', key, vars=defaults['keys'])
        else:
            opts['keys'] = defaults['keys']

        return opts

    desc='Polyomino tessellation game written in wxPython'
    arg_parser = ArgumentParser(description=desc,
                                formatter_class=ArgumentDefaultsHelpFormatter)
    arg_parser.add_argument('-c', '--config-file',
                            default=defaults['config_file'],
                            type=config_file,
                            help='Specify location of the config file')
    arg_parser.add_argument('-s', '--size',
                            default='{0[width]}x{0[height]}'.format(defaults['size']),
                            type=size,
                            help='Board size')
    arg_parser.add_argument('-g', '--geometry',
                            default='{0[width]}x{0[height]}'.format(default_geometry(defaults['size'])),
                            dest='geometry',
                            type=geometry,
                            help='Specify window geometry; see X(7) for info on'
                                 ' how to specify geometries')
    arg_parser.add_argument('-S', '--speed',
                            default=defaults['speed'],
                            type=int,
                            help='Game speed; if set, the game will run'
                                 ' constantly at this speed regardless of the'
                                 ' number of removed rows')

    args = vars(arg_parser.parse_args())

    # Load configs from config file
    opts = get_config(args['config_file'])

    # Default window size to a scale factor of the board size
    if args['size'] != defaults['size']:
        if (args['geometry']['width'] == default_geometry(defaults['size'])['width']
            and args['geometry']['height'] == default_geometry(defaults['size'])['height']):
            args['geometry'].update(default_geometry(args['size']))

    # Override configs with values from command line
    opts.update(args)

    return opts


def write_config(opts):
    '''
    Save game configs to file when config dialog is closed
    '''
    # TODO


def pysirtet():
    '''
    Execute the game
    '''
    try:
        app = wx.App()
        PySirtet(get_opts())
        app.MainLoop()
    except KeyboardInterrupt:
        exit(0)


if __name__ == '__main__':
    pysirtet()
