#!/usr/bin/env python2

import re
import wx
import random
from argparse import ArgumentParser,ArgumentTypeError,ArgumentDefaultsHelpFormatter


class Polyomino(object):
    coords_table = (
        ((0, 0),     (0, 0),     (0, 0),     (0, 0)),
        ((0, -1),    (0, 0),     (-1, 0),    (-1, 1)),
        ((0, -1),    (0, 0),     (1, 0),     (1, 1)),
        ((0, -1),    (0, 0),     (0, 1),     (0, 2)),
        ((-1, 0),    (0, 0),     (1, 0),     (0, 1)),
        ((0, 0),     (1, 0),     (0, 1),     (1, 1)),
        ((-1, -1),   (0, -1),    (0, 0),     (0, 1)),
        ((1, -1),    (0, -1),    (0, 0),     (0, 1))
    )

    def __init__(self, coords=(), colors={}):
        self.coords = coords
        self.colors = colors

    def set_random_shape(self):
        self.set_shape(random.randint(1, 7))

    def x(self, index):
        return self.coords[index][0]

    def y(self, index):
        return self.coords[index][1]

    def setX(self, index, x):
        self.coords[index][0] = x

    def setY(self, index, y):
        self.coords[index][1] = y

    def minX(self):
        m = self.coords[0][0]
        for i in range(4):
            m = min(m, self.coords[i][0])

        return m

    def maxX(self):
        m = self.coords[0][0]
        for i in range(4):
            m = max(m, self.coords[i][0])

        return m

    def minY(self):
        m = self.coords[0][1]
        for i in range(4):
            m = min(m, self.coords[i][1])

        return m

    def maxY(self):
        m = self.coords[0][1]

        for i in range(4):
            m = max(m, self.coords[i][1])

        return m

    def rotated_left(self):
        result = Polyomino()
        result.piece_shape = self.piece_shape

        for i in range(4):
            result.setX(i, self.y(i))
            result.setY(i, -self.x(i))

        return result

    def rotated_right(self):
        result = Polyomino()
        result.piece_shape = self.piece_shape

        for i in range(4):
            result.setX(i, -self.y(i))
            result.setY(i, self.x(i))

        return result


tetrominoes = {
    'Z': Polyomino(
        coords=((0, -1), (0, 0), (-1, 0), (-1, 1)),
        colors={'normal': '#CC6666',
                'light' : '#F89FAB',
                'dark'  : '#803C3B'}
    ),
    'S': Polyomino(
        coords=((0, -1), (0, 0), (1, 0), (1, 1)),
        colors={'normal': '#66CC66',
                'light' : '#79FC79',
                'dark'  : '#3B803B'}
    ),
    'l': Polyomino(
        coords=((0, -1), (0, 0), (0, 1), (0, 2)),
        colors={'normal': '#6666CC',
                'light' : '#7979FC',
                'dark'  : '#3B3B80'}
    ),
    'T': Polyomino(
        coords=((-1, 0), (0, 0), (1, 0), (0, 1)),
        colors={'normal': '#CCCC66',
                'light' : '#FCFC79',
                'dark'  : '#80803B'}
    ),
    'o': Polyomino(
        coords=((0, 0), (1, 0), (0, 1), (1, 1)),
        colors={'normal': '#CC66CC',
                'light' : '#FC79FC',
                'dark'  : '#803B80'}
    ),
    'L': Polyomino(
        coords=((-1, -1), (0, -1), (0, 0), (0, 1)),
        colors={'normal': '#66CCCC',
                'light' : '#79FCFC',
                'dark'  : '#3B8080'}
    ),
    'J': Polyomino(
        coords=((1, -1), (0, -1), (0, 0), (0, 1)),
        colors={'normal': '#DAAA00',
                'light' : '#FCC600',
                'dark'  : '#806200'}
    ),
}


class PySirtet(wx.Frame):
    '''
    Main game window
    '''
    def __init__(self, opts):
        '''
        Setup game window
        '''
        # Create frame
        wx.Frame.__init__(self,
                          parent=None,
                          title='PySirtet',
                          size=(opts['geom']['wid'], opts['geom']['hei']))

        # Store program options
        self.opts = opts

        # Setup additional features and attributes of the game window
        self.statusbar = self.CreateStatusBar()
        self.statusbar.SetStatusText('0')

        self.board = Board(self, opts)
        self.board.SetFocus()
        self.board.start()

        self.Centre()
        self.Show(True)


class Board(wx.Panel):
    BoardWidth = 10
    BoardHeight = 22
    Speed = 300
    ID_TIMER = 1

    def __init__(self, parent, opts):
        '''
        Setup block board
        '''
        # Create panel
        wx.Panel.__init__(self, parent)

        # Store program options
        self.opts = opts

        # Setup additional features and attributes of the game panel
        self.timer = wx.Timer(self, Board.ID_TIMER)
        self.is_waiting_after_line = False
        self.cur_piece = Polyomino()
        self.next_piece = Polyomino()
        self.curX = 0
        self.curY = 0
        self.num_lines_removed = 0
        self.board = []

        self.is_started = False
        self.is_paused = False

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_TIMER, self.OnTimer, id=Board.ID_TIMER)

        self.clear_board()

    def shape_at(self, x, y):
        return self.board[(y*Board.BoardWidth) + x]

    def set_shape_at(self, x, y, shape):
        self.board[(y*Board.BoardWidth) + x] = shape

    def square_width(self):
        return self.GetClientSize().GetWidth()/Board.BoardWidth

    def square_height(self):
        return self.GetClientSize().GetHeight()/Board.BoardHeight

    def start(self):
        if self.is_paused:
            return

        self.is_started = True
        self.is_waiting_after_line = False
        self.num_lines_removed = 0
        self.clear_board()

        self.new_piece()
        self.timer.Start(Board.Speed)

    def pause(self):
        if not self.is_started:
            return

        self.is_paused = not self.is_paused
        statusbar = self.GetParent().statusbar

        if self.is_paused:
            self.timer.Stop()
            statusbar.SetStatusText('{} (paused)'.format(self.num_lines_removed))
        else:
            self.timer.Start(Board.Speed)
            statusbar.SetStatusText(str(self.num_lines_removed))

        self.Refresh()

    def clear_board(self):
        for i in range(Board.BoardHeight*Board.BoardWidth):
            self.board.append(Tetrominoes.NoShape)

    def OnPaint(self, event):
        dc = wx.PaintDC(self)

        size = self.GetClientSize()
        board_top = size.GetHeight() - Board.BoardHeight*self.square_height()

        for i in range(Board.BoardHeight):
            for j in range(Board.BoardWidth):
                shape = self.shape_at(j, Board.BoardHeight - i - 1)
                if shape != Tetrominoes.NoShape:
                    self.draw_square(dc,
                        0 + j*self.square_width(),
                        board_top + i*self.square_height(), shape)

        if self.cur_piece.shape() != Tetrominoes.NoShape:
            for i in range(4):
                x = self.curX + self.cur_piece.x(i)
                y = self.curY - self.cur_piece.y(i)
                self.draw_square(dc, 0 + x*self.square_width(),
                    board_top + (Board.BoardHeight - y - 1)*self.square_height(),
                    self.cur_piece.shape())


    def OnKeyDown(self, event):
        if not self.is_started or self.cur_piece.shape() == Tetrominoes.NoShape:
            event.Skip()
            return

        keycode = event.GetKeyCode()

        if keycode == ord('P') or keycode == ord('p'):
            self.pause()
            return
        if self.is_paused:
            return
        elif keycode == wx.WXK_LEFT:
            self.try_move(self.cur_piece, self.curX - 1, self.curY)
        elif keycode == wx.WXK_RIGHT:
            self.try_move(self.cur_piece, self.curX + 1, self.curY)
        elif keycode == wx.WXK_DOWN:
            self.try_move(self.cur_piece.rotated_right(), self.curX, self.curY)
        elif keycode == wx.WXK_UP:
            self.try_move(self.cur_piece.rotated_left(), self.curX, self.curY)
        elif keycode == wx.WXK_SPACE:
            self.drop_down()
        elif keycode == ord('D') or keycode == ord('d'):
            self.one_line_down()
        else:
            event.Skip()


    def OnTimer(self, event):
        if event.GetId() == Board.ID_TIMER:
            if self.is_waiting_after_line:
                self.is_waiting_after_line = False
                self.new_piece()
            else:
                self.one_line_down()
        else:
            event.Skip()


    def drop_down(self):
        newY = self.curY

        while newY > 0:
            if not self.try_move(self.cur_piece, self.curX, newY - 1):
                break
            newY -= 1

        self.piece_dropped()

    def one_line_down(self):
        if not self.try_move(self.cur_piece, self.curX, self.curY - 1):
            self.piece_dropped()


    def piece_dropped(self):
        for i in range(4):
            x = self.curX + self.cur_piece.x(i)
            y = self.curY - self.cur_piece.y(i)
            self.set_shape_at(x, y, self.cur_piece.shape())

        self.remove_full_lines()

        if not self.is_waiting_after_line:
            self.new_piece()


    def remove_full_lines(self):
        num_full_lines = 0

        statusbar = self.GetParent().statusbar

        rows_to_remove = []

        for i in range(Board.BoardHeight):
            n = 0
            for j in range(Board.BoardWidth):
                if not self.shape_at(j, i) == Tetrominoes.NoShape:
                    n = n + 1

            if n == 10:
                rows_to_remove.append(i)

        rows_to_remove.reverse()

        for m in rows_to_remove:
            for k in range(m, Board.BoardHeight):
                for l in range(Board.BoardWidth):
                        self.set_shape_at(l, k, self.shape_at(l, k + 1))

            num_full_lines = num_full_lines + len(rows_to_remove)

            if num_full_lines > 0:
                self.num_lines_removed = self.num_lines_removed + num_full_lines
                statusbar.SetStatusText(str(self.num_lines_removed))
                self.is_waiting_after_line = True
                self.cur_piece.set_shape(Tetrominoes.NoShape)
                self.Refresh()


    def new_piece(self):
        self.cur_piece = self.next_piece
        statusbar = self.GetParent().statusbar
        self.next_piece.set_random_shape()
        self.curX = Board.BoardWidth/2 + 1
        self.curY = Board.BoardHeight - 1 + self.cur_piece.minY()

        if not self.try_move(self.cur_piece, self.curX, self.curY):

            self.cur_piece.set_shape(Tetrominoes.NoShape)
            self.timer.Stop()
            self.is_started = False
            statusbar.SetStatusText('Game over')


    def try_move(self, new_piece, newX, newY):
        for i in range(4):

            x = newX + new_piece.x(i)
            y = newY - new_piece.y(i)

            if x < 0 or x >= Board.BoardWidth or y < 0 or y >= Board.BoardHeight:
                return False
            if self.shape_at(x, y) != Tetrominoes.NoShape:
                return False

        self.cur_piece = new_piece
        self.curX = newX
        self.curY = newY
        self.Refresh()

        return True


    def draw_square(self, dc, x, y, shape):
        colors = ['#000000', '#CC6666', '#66CC66', '#6666CC',
                  '#CCCC66', '#CC66CC', '#66CCCC', '#DAAA00']

        light = ['#000000', '#F89FAB', '#79FC79', '#7979FC',
                 '#FCFC79', '#FC79FC', '#79FCFC', '#FCC600']

        dark = ['#000000', '#803C3B', '#3B803B', '#3B3B80',
                 '#80803B', '#803B80', '#3B8080', '#806200']

        pen = wx.Pen(light[shape])
        pen.SetCap(wx.CAP_PROJECTING)
        dc.SetPen(pen)

        dc.DrawLine(x, y + self.square_height() - 1, x, y)
        dc.DrawLine(x, y, x + self.square_width() - 1, y)

        darkpen = wx.Pen(dark[shape])
        darkpen.SetCap(wx.CAP_PROJECTING)
        dc.SetPen(darkpen)

        dc.DrawLine(x + 1, y + self.square_height() - 1,
            x + self.square_width() - 1, y + self.square_height() - 1)
        dc.DrawLine(x + self.square_width() - 1,
        y + self.square_height() - 1, x + self.square_width() - 1, y + 1)

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(wx.Brush(colors[shape]))
        dc.DrawRectangle(x + 1, y + 1, self.square_width() - 2,
        self.square_height() - 2)


def get_opts():
    '''
    Setup program options
    '''
    def geom(arg):
        '''
        Validate geometry argument
        '''
        # Match data
        geom_pattern = (r'(?P<wid>\d+)'         # width pixels
                        r'(?P<mlt>[xX])'        # times
                        r'(?P<hei>\d+)'         # height pixels
                        r'(?:'                  # optional non-capturing group
                            r'(?P<xsgn>[+-])*'  # x sign
                            r'(?P<xoff>\d+)*'   # x offset
                            r'(?P<ysgn>[+-])*'  # y sign
                            r'(?P<yoff>\d+)*'   # y offset
                        r')*')                  # close optional group
        match = re.match(geom_pattern, arg)

        # Validate size
        if not match:
            raise ArgumentTypeError('Incorrect size')

        # Validate offset
        extra = ('xsgn', 'xoff', 'ysgn', 'yoff')
        found_extra = [match.group(token) for token in extra]
        if any(found_extra) and not all(found_extra):
            raise ArgumentTypeError('Incorrect offset')

        # Construct return data and return
        geom = {}
        for token in ('wid', 'hei', 'xoff', 'yoff'):
            value = match.group(token)
            geom[token] = int(value) if value is not None else 0
        for token in ('mlt', 'xsgn', 'ysgn'):
            value = match.group(token)
            geom[token] = value if value is not None else '+'
        return geom

    desc='Polyomino tessellation game written in wxPython'
    arg_parser = ArgumentParser(description=desc,
                                formatter_class=ArgumentDefaultsHelpFormatter)
    arg_parser.add_argument('-g', '--geometry',
                            dest='geom',
                            default='180x380',
                            type=geom,
                            help='specify window geometry; see X(7) for info on'
                                 ' how to specify geometries')

    return vars(arg_parser.parse_args())


def pysirtet():
    '''
    Execute the game
    '''
    try:
        opts = get_opts()
        app = wx.App()
        PySirtet(opts)
        app.MainLoop()
    except KeyboardInterrupt:
        exit(0)


if __name__ == '__main__':
    pysirtet()
